This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Tasks:
1.  Build out documentation and a docs badge
    -   Include all-stops-out tutorial on defining a new dimension "RadDims"
    -   Add angle to the dimension list
    -   Create a new unit registry with that dimension 
    -   Re-tool sin, cos, tan rules on this particular dimension
2.  Add "unit_info(u::Union{Dimension, AbstractUnit{Dimension}})" 
    -   Maps dimensions to a meaning (like Force or Inductance) and lists other units of that dimension
    -   This can be done without documentation 
        -   Use Dict{Dimension,String} to find dimension "meaning" (determine this by unique dimensions)
        -   Iterate over registry and list other units that match the query dimension
3.  Consider a special object QuantTransform(scale::AbstractArray, units::UnitTransform)<:AbstractArray{<:Quantity}
    -   I may still need to build "zero(::Type{Quantity{T, D}})" to produce a special "Union{D{R},UnknownDims}"
        -   There's too many "zero(T)" calls in base library, need to define UknownDims{P}()
        -   You can add any quantity to "Quantity(0, UknownDims())" to return just adding the numbers
        -   This logic is done at the "equaldims" function
        
    -   This is a KILLER FEATURE because Unitful CANT DO THIS with mixed dimensions, and DynamicQuantities can't do this at all
    -   All CONSISTENT quantity transforms mQ can be broken down into mQ.scale, mQ.units
        -   For a matrix multiplication with a column vector to work, the matrix must be DIMENSINALLY CONSISTENT and COMPATIBLE with the vector
            -   Consider a type QuantTransorm{scale::T, units::AbstractUnitTransform}
        -   Multiplication of a vector quantity "v" with a quantity transform mQ can be expressed as
            -   mU = mQ.units::UnitTransform{colfac::AbstractVector{Dimensions{T}}, rowfac::AbstractVector{Dimensions{T}}} 
            -   Matrix(mU::UnitTransform) = mU.colfac .* mU.rowfac'
            -   mQ*v = mU.colfac.*(mQ.scale).*(mU.rowfac')*v
            -   scale  = ustrip_base.(mQ)
            -   colfac = dimension.(mQ[:,begin])
            -   rowfac = dimension.(mQ[ii,:])/colfac[ii]
                -   Result for rowfac must be the same for all ii
        -   UnitTransform mU can be easily inverted
            -   inv(mU) = UnitTransform(colfac=inv.(mU.rowfac), rowfac=inv.(mU.colfac))
        -   L-Divide can be done in stages (scalars first, and then units)
            -   y = fill(0.0*u"", size(mQ,1), size(x,2))
            -   y .= mQ.scale\ustrip_base.(x)
            -   y .*= inv(mQ.units)*x
    -   All SELF-CONSISTENT unit transforms ScalarUnitTransform can be factorized as mU = uscale.*(colfac.*inv.(colfac'))
        -   ScalarUnitTransform{scale::Dimensions{T}, colfac::AbstractVector{Dimensions{T}}} 
            -   The term (colfac.*inv.(colfac')) is idempotent for vectors with compatible dimensions
        -   ScalarUnitTransform can have many different operations
            -   Matrix Power -> mU^x = ScalarUnitTransform(uscale=mU.scale^x, colfac=mU.colfac)
            -   Transpose -> transpose(mU) = ScalarUnitTransform(uscale=mU.scale, colfac=inv.(mU.colfac))
            -   Matrix EXP -> exp(mU) = mU if mU.scale == u""
            -   Eigendecomposition -> eigenvalue .= mU.scale, eigenvectors .= mU.colfac.*inv.(colfac')
            -   Cholesky decomposition -> L = ScalarUnitTransform(sqrt(mU.scale), mU.colfac), R = ScalarUnitTransform(sqrt(mU.scale), inv.(mU.colfac))



import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)

Considerations:
N.  Consider commutative macro for promote_rule to prevent repetition
        https://discourse.julialang.org/t/techniques-for-defining-commutative-functions/113406/5
