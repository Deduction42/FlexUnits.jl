This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Major Changes:
1.  (breaking) `zero(::Quantity{T,D})` now outputs a new quanitity type Quantity{T, MirrorUnion{D}}
    -   This allows an "additive identity" as MirrorUnion{D} mirrors the dimensions in the other argument
    -   Enables functionality like var(X, dims=1) where X is a matrix of mixed units
    -   Behaviour also applies to `typemin` and `typemax` as well
2.  (breaking) `NoDims()` removed, make sure dimension objects have default arguments of zero
3.  (breaking) `quantity` removed, use Quantity instead
4.  (breaking) `UnitfulCallable` removed in favor of Quantity(f::Function, u::UnitMap)
5.  (breaking) `AbstractUnitTransform` is renamed to `AbstractUnitConverter` (AffineTrnasform is now AffineConverter)
6.  Added more promotion rules to convert to quantities
7.  FixRat32 is now exported


Current Tasks:
1.  Build out "unit mapping" objects 
    -   UnitOrDim{D} = Union{AbstractUnits{D}, D} where D<:AbstractDimensions
    -   UnitMap{U<:UnitOrDim, V<:AbstractVector{U}}(input::Vector{U}, output::Vector{U}) <: UnitLike (add "Pair" constructors)
    -   RUnitMap{U<:UnitOrDim, V::AbstractVector{U}}(input::V, scale::U=U()) <: UnitLike #Repeatable/Recursive unit map
    -   UnitMaps{U} = Union{UnitMap{U}, RUnitMap{U}}
    -   QuantLinMap{M<:AbstractMatrix, U<:UnitMap{D<:AbstractDimension}} <: AbstractMatrix{Quantity{D}} #Quantity matrix with linear mapping properties
    -   Deprecate UnitfulCallable and replace with Quantity{Function, UnitMap{U}}
    -   QuantLinMap adjoint inverts units but matrix adjoints don't (think Eigenvectors vs Covariance)

    Notes on above:      
    -   This is a KILLER FEATURE because Unitful CANT DO THIS with mixed dimensions, and DynamicQuantities can't do this at all
    -   All CONSISTENT quantity transforms mQ can be broken down into mQ.scale, mQ.units
        -   For a matrix multiplication with a column vector to work, the matrix must be DIMENSINALLY CONSISTENT and COMPATIBLE with the vector
            -   Consider a type QuantTransorm{scale::T, units::AbstractUnitMap}
        -   Multiplication of a vector quantity "v" with a quantity transform mQ can be expressed as
            -   mU = mQ.units::UnitMap{colfac::AbstractVector{Dimensions{T}}, rowfac::AbstractVector{Dimensions{T}}} 
            -   Matrix(mU::UnitMap) = mU.colfac .* mU.rowfac'
            -   mQ*v = mU.colfac.*(mQ.scale).*(mU.rowfac')*v
            -   scale  = ustrip_base.(mQ)
            -   colfac = dimension.(mQ[:,begin])
            -   rowfac = dimension.(mQ[ii,:])/colfac[ii]
                -   Result for rowfac must be the same for all ii
        -   UnitMap mU can be easily inverted
            -   inv(mU) = UnitMap(colfac=inv.(mU.rowfac), rowfac=inv.(mU.colfac))
        -   L-Divide can be done in stages (scalars first, and then units)
            -   y = fill(0.0*u"", size(mQ,1), size(x,2))
            -   y .= mQ.scale\ustrip_base.(x)
            -   y .*= inv(mQ.units)*x
    -   All SELF-CONSISTENT unit transforms ScalarUnitMap can be factorized as mU = uscale.*(colfac.*inv.(colfac'))
        -   ScalarUnitMap{scale::Dimensions{T}, colfac::AbstractVector{Dimensions{T}}} 
            -   The term (colfac.*inv.(colfac')) is idempotent for vectors with compatible dimensions
        -   ScalarUnitMap can have many different operations
            -   Matrix Power -> mU^x = ScalarUnitMap(uscale=mU.scale^x, colfac=mU.colfac)
            -   Transpose -> transpose(mU) = ScalarUnitMap(uscale=mU.scale, colfac=inv.(mU.colfac))
            -   Matrix EXP -> exp(mU) = mU if mU.scale == u""
            -   Eigendecomposition -> eigenvalue .= mU.scale, eigenvectors .= mU.colfac.*inv.(colfac')
            -   Cholesky decomposition -> L = ScalarUnitMap(sqrt(mU.scale), mU.colfac), R = ScalarUnitMap(sqrt(mU.scale), inv.(mU.colfac))


Backlog:
1.  Consider support for Unitful-like static-dimension quantities (SQuantity?) MAJOR FEATURE!!!
    -   Allows FlexUnits to be the best of both DynamicQuantities and Unitful
    -   Dimensions are a parameter, not a field, everything else should just work
        -   SQuantity(x::T, u) => SQuantity{T,u}(x)
        -   Dimensions work as a parameter. THIS IS HUGE!!!
        -   Units don't work, but this doesn't matter because only using dimensions has many benefits
            -   Less over-specialization
            -   No scalar conversions, which means theroetically zero overhead
            -   Use 'su"..."' to create a StaticUnit{D,T<:AbstractUnitTranform}
    -   Eager conversion to SI should reduce over-specialization
        -   String-macro "su" will produce a StaticQuantity (dimensions with the converter object)
        -   uconvert(su"...", q) will produce static quantities to the dimensions of "u"
    -   Promotion of quantities will revert to regular dynamic quantities
        -   This looks like it can be handled at the "with_ubase" interface level
2.  Build out documentation and a docs badge
    -   Include all-stops-out tutorial on defining a new dimension "RadDims"
    -   Add angle to the dimension list
    -   Create a new unit registry with that dimension 
    -   Re-tool sin, cos, tan rules on this particular dimension
3.  Add "unit_info(u::Union{Dimension, AbstractUnit{Dimension}})" 
    -   Maps dimensions to a meaning (like Force or Inductance) and lists other units of that dimension
    -   This can be done without documentation 
        -   Use Dict{Dimension,String} to find dimension "meaning" (determine this by unique dimensions)
        -   Iterate over registry and list other units that match the query dimension

#Static quantity that does compile-time unit conversion
struct SQuantity{T, D<:AbstractDimensions}
    value :: T
end
SQuantity(x::Any, u::AbstractDimensions) = SQuantity{typeof(x), u}(x)

#Static unit that contains a dimension parameter and the transform to get the unit to said dimension
struct StaticUnit{D, T<:AbstractUnitConverter}
    converter :: T
    symbol :: Symbol
end
StaticUnit(u::AffineUnits{D}) where D<:AbstractDimension = StaticUnit{dimension(u), AffineConverter}(uconvert(dimension(u), u))

#Multiplication with static units becomes easy thanks to the elegance of unit transforms
Base.*(x::T, u::StaticUnit{D}) where {T<:ARITHMETICS, D<:AbstractDimensions} = SQuantity{T,D}(u.transform(x))

import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)

Considerations:
N.  Consider commutative macro for promote_rule to prevent repetition
        https://discourse.julialang.org/t/techniques-for-defining-commutative-functions/113406/5
