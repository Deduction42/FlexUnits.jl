This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Changelog:
1.  Added support for linear algebra; LinmapQuant factorizes out units for efficient O(N+M) pure-unit ops while allowing efficient numeric methods to handle raw matrix ops
2.  Quantity now subtypes to Number, use FlexQuant for values that don't subtype to number (quantity auto-selects appropriate container)
3.  Multiplying with dynamic units now eagerly converts to dimensional quantities
4.  Re-added "quantity" constructor function, does not eagerly convert to dimensional quantity
5.  Replaced MirrorDims() dispatch with a sentinel value approach; this results in greatest compatibility of dynamic Quantity with Number

Current Tasks:
1.  Finish basic LinmapQuant/VectorQuant for +, -, *, /, \, lu, ^, exp, sin, cos, tan,
    -   Include linear_algebra.jl into the package and run tests
    -   Optimize Transpose and Adjoint methods
        -   Make sure any ambiguities get resolved (shouldn't be too many if using AdjointUmap)
    -   Continue Rodas5P experiment
    -   Add some factorizations with specialized getproperty methods
    -   Build out test suite to achieve adequate coverage

    Notes on Optimize Transpose and Ajoint Methods
    -   dotinv1/dotinv2 should be abstracted out as "firstmul"
        -   These methods in turn call "strictzip" which checks the inputs and output lengths
        -   "firstmul" iterates over the first row/column result and divides by the first element of uoutput
        -   can be generic if "getindex" and "uoutput" are specialized
    -   transpose and adjoint on AbstractDimsMap should be optimized and lazy
        -   See Julia's adjoint/transpose codebase 
            -   https://github.com/JuliaLang/LinearAlgebra.jl/blob/master/src/adjtrans.jl
        -   Creat a custom AdjointUmap which gets created/reversed by both "transpose" and "adjoint"
            -   This prevents subtyping to AbstractMatrix which could cause problems in the future
            -   Remove the "eager" transpose/adjoint methods (except for SymDimsMap, because that's a no-op)
        -   Define specific "dstrip" and "dimension" and "getindex" methods for Transpose(::LinmapQuant) and Adjoint(::LinmapQuant)
            -   Basically dimension(m::Transpose{<:LinmapQuant}) = transpose(dimension(transpose(m)))
        -   Define matrix-op shorcut methods for AdjointMap{DimsMap/RepDimsMap}, AdjointMap{DimsMap/RepDimsMap}

2.  Add LinearAlgebra extensions for certain factorizations
    -   overload the "getproperty" function to use the UnitMap to reconstruct the factoriation fields with units
        -   eig = eigen(A::LinmapQuant)
        -   eig.vectors = LinmapQuant(ustrip(eig).vectors, UnitMap(fill(ud"", N), unit(eig).u_in))
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other factorizations as well

3.  Build out documentation and a docs badge
    -   Remove MirrorDims 
    -   Add warnings around "Affine Delta" and "zero/oneunit"
    -   Add Examples
        -   The DynamicQ -> StaticQ -> DynamicQ (static intermediate) pattern with the PengRobinson benchmarks
        -   The unit dispatch pattern vs the static intermediate pattern
        -   DifferentialEquations if we can make them work
        -   Linear Dynamic System and Linear Algebra once added




Backlog:


4.  Add interactive unit functionality
    -   unit_index() (produces dict that lists all units for every dimension)
    -   simplify(q::Quantity{T,AbstractDimLike}) (lists all standard SI units, performs a greedy search to make units as terse as possible)
        e.g. simplify(1.0u"(m^2*kg)/s^3") = 1 kW


#Example of #3 is shown below

julia> using FlexUnits, .UnitRegistry

julia> (x, y, z) = 1u"m/s", 1u"kg", 1u"kW"
(1.0 m/s, 1.0 kg, 1000.0 (m² kg)/s³)

julia> T = Union{typeof(x),typeof(y), typeof(z)}
Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}

julia> v = T[x,y,z]
3-element Vector{Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}}:
 1.0 m/s
 1.0 kg
 1000.0 (m² kg)/s³

julia> map(x->x*2, v)
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> map(x->x*2, [x,y,z])
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> collect(map(x->x*2, (x,y,z)))
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> vcat((map(x->x*2, (x,y,z)))...)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³





#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)


