This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Major Changes:
1.  (breaking) `zero(::Quantity{T,D})` now outputs a new quanitity type Quantity{T, MirrorUnion{D}}
    -   This allows an "additive identity" as MirrorUnion{D} mirrors the dimensions in the other argument
    -   Enables functionality like var(X, dims=1) where X is a matrix of mixed units
    -   Behaviour also applies to `typemin` and `typemax` as well
2.  (breaking) `NoDims()` removed, make sure dimension objects have default arguments of zero
3.  (breaking) `quantity` removed, use Quantity instead
4.  (breaking) `UnitfulCallable` removed in favor of QuantMapping(f::Function, u::UnitMap)
5.  (breaking) `AbstractUnitTransform` is renamed to `AbstractUnitTransform` (AffineTrnasform is now AffineTransform)
6.  Added more promotion rules to convert to quantities
7.  FixRat32 is now exported
8.  Added "dstrip" as shorthand for "ustrip_base"
9.  Added "dconvert" to convert to the dimensions of the unit


Current Tasks:
Prioritize making StaticUnits more robust, as significant performance gains have been found (even over Unitful.jl)
1.  Deprecate AffineUnits entirely, rename it to Units{D,T<:AffineTransform}
    1   Define operators for AffineTrasnform (just before "Unit math")
        -   +(t::AffineTrnasform, x::Number) (add x to the offset)
        -   *(t::AffineTransform, x::Number) (multiply the scale by x)
        -   (-,/)
    2   Replace all calls to AffineUnits with appropriate Units versions
        -   Should be done manually
    3   Include "trasnform type" T under AbstractUnits{D,T}
    4   Subtype StaticUnits{D,T} under AbstractUnits{D,T}

2.  Make string macros produce static units (for performance reasons)
    -   u"km/hr" will produce StaticUnits, 5.0u"km/hr" will eagerly convert to SI
    -   ud"km/hr" will produce AffineUnits and will not eagerly convert

Backlog:
1.  Finish basic QuantLinMap functionality for +,-,*,/,\,^,exp, (and matrix trigs)
    -   This consists of building shortcuts for UnitMap types
    -   Output should be the most specific form of unit mapping possible
    -   Make sure operations convert to QuantLinMap and output that type

    Notes on above:      
    -   Matrix multiplication is ONLY valid with QuantLinMap and will ALWAYS produce a QuantLinMap
        -   Multiplication should convert both AbstractMatrix{Quantity} to QuantLinMap
        -   This may result in more allocations, but is more reliable in pointing out errors
        -   It is recommendable to only store matrices as QuantLinMap if linear algebra is intended

2.  Add LinearAlgebra extensions for certain factorizations
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other transformations as well


3.  Build out documentation and a docs badge
    -   Include all-stops-out tutorial on defining a new dimension "RadDims"
    -   Add angle to the dimension list
    -   Create a new unit registry with that dimension 
    -   Re-tool sin, cos, tan rules on this particular dimension
4.  Add LinearAlgebra extensions for QuantLinMap
5.  Add "unit_info(u::Union{Dimension, AbstractUnit{Dimension}})" 
    -   Maps dimensions to a meaning (like Force or Inductance) and lists other units of that dimension
    -   This can be done without documentation 
        -   Use Dict{Dimension,String} to find dimension "meaning" (determine this by unique dimensions)
        -   Iterate over registry and list other units that match the query dimension


#====================================================================================================
Strategy #1 Regular `Quantity` with StaticUnit types
====================================================================================================#
struct StaticDim{D} 
    function StaticDim{D}() where D
        return (D isa AbstractDimension) ? new{D}() : error("Type parameter must be a dimension")
    end
end #(where D is a dimenison)
StaticDim(D) = StaticDim{D}()
StaticDim{D}(d::AbstractDimension) = (D == d) ? StaticDim{D} : throw(ArgumentError("Dimesion $(d) must be equal to $(D)"))

struct StaticUnit{D, C<:AbstractUnitTransform} #(where D is a dimenison)
    todims :: C
    symbol :: Symbol
    function StaticUnit{D}(conv::C, symb=DEFAULT_USYMBOL::Symbol) where {D, C<:AbstractUnitTransform}
        return (D isa AbstractDimension) ? new{D}(conv, symb) : error("Type parameter must be a dimension")
    end
end

StaticUnit(u::AffineUnits) = StaticUnit{dimension(u)}(uconvert(dimension(u), u), u.symbol)
uconvert(utarget::StaticDim{D}, ucurrent::StaticUnit{D}) = ucurrent.todims

function ubase(q::AbstractQuantity{T, StaticUnit{D}}) where {T,D}
    x = unit(q).converter(ustrip(q))
    return Quantity{typeof(x), StaticDim{D}}(x, StaticDim{D}())
end

#====================================================================================================
Strategy #2 (if #1 fails)
====================================================================================================#
#Static quantity that does compile-time unit conversion
struct SQuantity{T, D<:AbstractDimensions}
    value :: T
end
SQuantity(x::Any, u::AbstractDimensions) = SQuantity{typeof(x), u}(x)

#Static unit that contains a dimension parameter and the transform to get the unit to said dimension
struct StaticUnit{D, T<:AbstractUnitTransform}
    converter :: T
    symbol :: Symbol
end
StaticUnit(u::AffineUnits{D}) where D<:AbstractDimension = StaticUnit{dimension(u), AffineTransform}(uconvert(dimension(u), u))

#Multiplication with static units becomes easy thanks to the elegance of unit transforms
Base.*(x::T, u::StaticUnit{D}) where {T<:ARITHMETICS, D<:AbstractDimensions} = SQuantity{T,D}(u.transform(x))






#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)

Considerations:
N.  Consider commutative macro for promote_rule to prevent repetition
        https://discourse.julialang.org/t/techniques-for-defining-commutative-functions/113406/5
