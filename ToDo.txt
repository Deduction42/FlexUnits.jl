This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Major Changes:
1.  (breaking) `zero(::Quantity{T,D})` now outputs a new quanitity type Quantity{T, MirrorUnion{D}}
    -   This allows an "additive identity" as MirrorUnion{D} mirrors the dimensions in the other argument
    -   Enables functionality like var(X, dims=1) where X is a matrix of mixed units
    -   Behaviour also applies to `typemin` and `typemax` as well
2.  (breaking) `NoDims()` removed, make sure dimension objects have default arguments of zero
3.  (breaking) `quantity` removed, use Quantity instead
4.  (breaking) promotion rules convert to quantities
4.  FixRat32 is now exported


Current Tasks:
1.  Add support to MirrorDims() to allow zero(Quantity{T,D}) + Quantity{T,D}(...) = Quantity{T,D}(...)
    -   Remove NoDims() (it's unneeded)
    -   See if we can remove "constructorof" and "quantity"
    -   Change promotion rules so that Quantity{T<:ARITHMETICS} + ARITHMETICS promotes to Quantity{T} using Quantity(x, D())

2.  Build out "transform" objects 
    -   UnitTransform{U<:Union{AbstractUnits, AbstractDimensions}, input::Vector, output::Vector} <: UnitLike (add "Pair" constructors)
    -   SUnitTransform{U<:Union{AbstractUnits, AbstractDimensions}, input::Vector, scale::U} <: UnitLike
    -   QuantTransform{M<:AbstractMatrix, U<:UnitTransform} <: AbstractMatrix{Quantity{D}}
    -   Deprecate UnitfulCallable and replace with Quantity{Function, UnitTransform}
    -   QuantTransform adjoint inverts units but matrix adjoints don't (think Eigenvectors)

X.  Consider a special object QuantTransform(scale::AbstractArray, units::UnitTransform)<:AbstractArray{<:Quantity}        
    -   This is a KILLER FEATURE because Unitful CANT DO THIS with mixed dimensions, and DynamicQuantities can't do this at all
    -   All CONSISTENT quantity transforms mQ can be broken down into mQ.scale, mQ.units
        -   For a matrix multiplication with a column vector to work, the matrix must be DIMENSINALLY CONSISTENT and COMPATIBLE with the vector
            -   Consider a type QuantTransorm{scale::T, units::AbstractUnitTransform}
        -   Multiplication of a vector quantity "v" with a quantity transform mQ can be expressed as
            -   mU = mQ.units::UnitTransform{colfac::AbstractVector{Dimensions{T}}, rowfac::AbstractVector{Dimensions{T}}} 
            -   Matrix(mU::UnitTransform) = mU.colfac .* mU.rowfac'
            -   mQ*v = mU.colfac.*(mQ.scale).*(mU.rowfac')*v
            -   scale  = ustrip_base.(mQ)
            -   colfac = dimension.(mQ[:,begin])
            -   rowfac = dimension.(mQ[ii,:])/colfac[ii]
                -   Result for rowfac must be the same for all ii
        -   UnitTransform mU can be easily inverted
            -   inv(mU) = UnitTransform(colfac=inv.(mU.rowfac), rowfac=inv.(mU.colfac))
        -   L-Divide can be done in stages (scalars first, and then units)
            -   y = fill(0.0*u"", size(mQ,1), size(x,2))
            -   y .= mQ.scale\ustrip_base.(x)
            -   y .*= inv(mQ.units)*x
    -   All SELF-CONSISTENT unit transforms ScalarUnitTransform can be factorized as mU = uscale.*(colfac.*inv.(colfac'))
        -   ScalarUnitTransform{scale::Dimensions{T}, colfac::AbstractVector{Dimensions{T}}} 
            -   The term (colfac.*inv.(colfac')) is idempotent for vectors with compatible dimensions
        -   ScalarUnitTransform can have many different operations
            -   Matrix Power -> mU^x = ScalarUnitTransform(uscale=mU.scale^x, colfac=mU.colfac)
            -   Transpose -> transpose(mU) = ScalarUnitTransform(uscale=mU.scale, colfac=inv.(mU.colfac))
            -   Matrix EXP -> exp(mU) = mU if mU.scale == u""
            -   Eigendecomposition -> eigenvalue .= mU.scale, eigenvectors .= mU.colfac.*inv.(colfac')
            -   Cholesky decomposition -> L = ScalarUnitTransform(sqrt(mU.scale), mU.colfac), R = ScalarUnitTransform(sqrt(mU.scale), inv.(mU.colfac))


Backlog:
1.  Consider support for Unitful-like static-dimension quantities (SdQuantity?) THIS COULD BE THE ONE PACKAGE TO RULE THEM ALL!!!
    -   Dimensions are a parameter, not a field, everything else should just work
        -   SdQuantity(x::T, u) => SdQuantity{T,u}(x)
        -   Dimensions work as a parameter. THIS IS HUGE!!!
        -   Units don't work, but this doens't matter, compiling dimensions only reduces specialization
    -   Eager conversion to SI should reduce over-specialization
        -   String-macro "sdq" will produce a "static quantity" in SI
        -   sdconvert(u"...", q) will produce static quantities to the dimensions of "u"
    -   Promotion of quantities will revert to regular dynamic quantities
        -   This looks like it can be handled at the "with_ubase" interface level
2.  Build out documentation and a docs badge
    -   Include all-stops-out tutorial on defining a new dimension "RadDims"
    -   Add angle to the dimension list
    -   Create a new unit registry with that dimension 
    -   Re-tool sin, cos, tan rules on this particular dimension
3.  Add "unit_info(u::Union{Dimension, AbstractUnit{Dimension}})" 
    -   Maps dimensions to a meaning (like Force or Inductance) and lists other units of that dimension
    -   This can be done without documentation 
        -   Use Dict{Dimension,String} to find dimension "meaning" (determine this by unique dimensions)
        -   Iterate over registry and list other units that match the query dimension




import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)

Considerations:
N.  Consider commutative macro for promote_rule to prevent repetition
        https://discourse.julialang.org/t/techniques-for-defining-commutative-functions/113406/5
