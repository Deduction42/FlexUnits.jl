This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Changelog:
1.  Added support for linear algebra; LinmapQuant factorizes out units for efficient O(N+M) pure-unit ops while allowing efficient numeric methods to handle raw matrix ops
2.  Quantity now subtypes to Number, use FlexQuant for values that don't subtype to number (quantity auto-selects appropriate container)
3.  Multiplying with dynamic units now eagerly converts to dimensional quantities
4.  Re-added "quantity" constructor function, does not eagerly convert to dimensional quantity
5.  Replaced MirrorDims() dispatch with a sentinel value approach; this results in greatest compatibility of dynamic Quantity with Number

Current Tasks:
1.  Finish basic LinmapQuant/VectorQuant for +, -, *, /, \, lu, ^, exp, sin, cos, tan,
    -   For double-argument functions, use an internal method like qm_add, qm_sub, qm_mul, qm_ldiv, qm_rdiv, qm_pow
        -   This allows you to use something generic like the line below without messing up opertors
                qm_mul(m1::AbstactMatrix, m2::AbstractMatrix) = LinmapQuant(dstrip(m1)*dstrip(m2), dimension(m1)*dimension(m2))
        -   Overload the Base.(...) operator methods on specific matrix types, this makes it easier for users to patch their own matrices later
        -   Overload *(m::AbstractMatrix, u::UnitMap) -> LinmapQuant(m, u)
    -   Create a VectorQuant with separated dimensions and values 
        -   Matrix multiplication is O(N) for units not O(M*N)
        -   Fewer allocations if we just keep dimensions and values separate
        -   adjoint(v::VectorQuant) produces a LinmapQuant with u_out = SVector{1}(D()) u_in = inv.(dimension(v))
    -   Operations with unit-factorized matrices will produce unit-factorized matrices
        -   Multiplication with QuantMatrixDims(m) produces output units and is O(N^2) already
        -   This is faster than raw multiplication
    -   Continue Rodas5P experiment after linear algebra is completed
    -   Factorizations are subtyped under FactorQuant{F,U}
        -   Different "getfield" methods can be dispatched based on the Factorization type F 
        -   FactorQuant is different because LinmapQuant subtypes to "Matrix", while FactorQuant doesn't subtype to anything
        -   Use "methodswith(Factorization)" to see what methods FactorQuant will need to support at a high level
    -   "lu" is particularly important because pivoting fails
        -   pivoting is best interpreted as a reordering operation, not a proper multiplication, so there will be unit conflicts
        -   pivot matrices themselves can be fixed by making the pivot matrix have "unknown" units on zeros and a dimensionless diagonal
            -   the transpose of a pivot matrix is the same as its inverse
            -   see the following link on now "getproperty" works on lu factorizations
                -   https://github.com/JuliaLang/LinearAlgebra.jl/blob/b1f48a442ba5f41479d4fb6f3e931b1ac2f21059/src/lu.jl#L440
        -   inv on an LUQuant is basically LinmapQuant(inv(ustrip(luq)), inv(unit(luq)))
    -   This consists of building shortcuts for UnitMap types
    -   Output should be the most specific form of unit mapping possible
    -   Make sure operations convert to LinmapQuant and output that type

    Notes on above:      
    -   Matrix multiplication is ONLY valid with LinmapQuant and will ALWAYS produce a LinmapQuant/VectorQuant
        -   Multiplication should "separate" dimensions and values 
            - Use dimension(a::AbstractMatrix) = QuantMatrixDims(a)
            - This prevents allocations and should even work on non-quantity arrays
            - An inner if-statement on the multiplication can case out AbstractMatrix{<:QuantUnion} and apply dstrip
            - Dimension multiplication is only defined for QuantMatrixDims and 
    -   Multiplying a dense array of dimensions with a factored matrix is 2N (same as factoring, so you don't need it)
        -   Factoring may not be possible if some dimensions are unknown, so outright multiplication is more reliable
        -   dn = d_dense*dn = canonical!(UnitMap(u_out = d_dense*d0.u_out, u_in = d0.u_in))
        -   dn = dn*d_dense = canonical!(UnitMap(u_out = d0.u_out, u_in = inv.( (inv.(d0.u_in)'*d_dense)' )))
                            = canonical!(UnitMap(u_out = d0.u_out, u_in = inv.(d_dense'*inv.(d0.u_in))))
    -   UnitMap is not unique for a LinmapQuant
        -   Matrix multiplication between UnitMap should have a canonical form to prevent confusion on "=="
        -   The canconical form has u_in[1] == u"" (as per the matrix constructor)
        -   Define the function "canonical!" to convert UnitMap to this form
            -   Will need to case out mutable and immutable versions
            -   https://docs.sciml.ai/ArrayInterface/stable/indexing/#ArrayInterface.can_setindex


2.  Add LinearAlgebra extensions for certain factorizations
    -   overload the "getproperty" function to use the UnitMap to reconstruct the factoriation fields with units
        -   eig = eigen(A::LinmapQuant)
        -   eig.vectors = LinmapQuant(ustrip(eig).vectors, UnitMap(fill(ud"", N), unit(eig).u_in))
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other factorizations as well

3.  Build out documentation and a docs badge
    -   Remove MirrorDims 
    -   Add warnings around "Affine Delta" and "zero/oneunit"
    -   Add Examples
        -   The DynamicQ -> StaticQ -> DynamicQ (static intermediate) pattern with the PengRobinson benchmarks
        -   The unit dispatch pattern vs the static intermediate pattern
        -   DifferentialEquations if we can make them work
        -   Linear Dynamic System and Linear Algebra once added




Backlog:


4.  Add interactive unit functionality
    -   unit_index() (produces dict that lists all units for every dimension)
    -   simplify(q::Quantity{T,AbstractDimLike}) (lists all standard SI units, performs a greedy search to make units as terse as possible)
        e.g. simplify(1.0u"(m^2*kg)/s^3") = 1 kW


#Example of #3 is shown below

julia> using FlexUnits, .UnitRegistry

julia> (x, y, z) = 1u"m/s", 1u"kg", 1u"kW"
(1.0 m/s, 1.0 kg, 1000.0 (m² kg)/s³)

julia> T = Union{typeof(x),typeof(y), typeof(z)}
Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}

julia> v = T[x,y,z]
3-element Vector{Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}}:
 1.0 m/s
 1.0 kg
 1000.0 (m² kg)/s³

julia> map(x->x*2, v)
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> map(x->x*2, [x,y,z])
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> collect(map(x->x*2, (x,y,z)))
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> vcat((map(x->x*2, (x,y,z)))...)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³





#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)


