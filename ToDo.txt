This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood

Changelog:
1.  Quantity now subtypes to Number, use FlexQuant for values that don't subtype to number (quantity auto-selects appropriate container)
2.  Multiplying with dynamic units now eagerly converts to dimensional quantities
3.  Re-added "quantity" constructor function, does not eagerly convert to dimensional quantity
4.  Replaced MirrorDims() dispatch with a sentinel value approach; this results in greatest compatibility of dynamic Quantity with Number

Current Tasks:
1.  Finish basic LinmapQuant functionality for +, -, *, /, \, ^, exp, lu, sin, cos, tan
    -   "lu" is particularly important because pivoting fails
        -   pivoting is best interpreted as a reordering operation, not a proper multiplication, so there will be unit conflicts
        -   pivot matrices themselves can be fixed by making the pivot matrix have "unknown" units on zeros and a dimensionless diagonal
            -   the transpose of a pivot matrix is the same as its inverse
            -   see the following link on now "getproperty" works on lu factorizations
                -   https://github.com/JuliaLang/LinearAlgebra.jl/blob/b1f48a442ba5f41479d4fb6f3e931b1ac2f21059/src/lu.jl#L440
        -   inv on an LUQuant is basically LinmapQuant(inv(ustrip(luq)), inv(unit(luq)))
    -   This consists of building shortcuts for UnitMap types
    -   Output should be the most specific form of unit mapping possible
    -   Make sure operations convert to LinmapQuant and output that type

    Notes on above:      
    -   Matrix multiplication is ONLY valid with LinmapQuant and will ALWAYS produce a LinmapQuant
        -   Multiplication should convert AbstractMatrix{Union{Quantity,NumberQuant}} to LinmapQuant
        -   This may result in more allocations, but is more reliable in pointing out errors
        -   It is recommendable to only store matrices as LinmapQuant if linear algebra is intended

2.  Add LinearAlgebra extensions for certain factorizations
    -   overload the "getproperty" function to use the UnitMap to reconstruct the factoriation fields with units
        -   eig = eigen(A::LinmapQuant)
        -   eig.vectors = LinmapQuant(ustrip(eig).vectors, UnitMap(fill(ud"", N), unit(eig).u_in))
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other factorizations as well

3.  Build out documentation and a docs badge
    -   Remove MirrorDims 
    -   Add warnings around "Affine Delta" and "zero/oneunit"
    -   Add Examples
        -   The DynamicQ -> StaticQ -> DynamicQ (static intermediate) pattern with the PengRobinson benchmarks
        -   The unit dispatch pattern vs the static intermediate pattern
        -   DifferentialEquations if we can make them work
        -   Linear Dynamic System and Linear Algebra once added




Backlog:


4.  Add interactive unit functionality
    -   unit_index() (produces dict that lists all units for every dimension)
    -   simplify(q::Quantity{T,AbstractDimLike}) (lists all standard SI units, performs a greedy search to make units as terse as possible)
        e.g. simplify(1.0u"(m^2*kg)/s^3") = 1 kW


#Example of #3 is shown below

julia> using FlexUnits, .UnitRegistry

julia> (x, y, z) = 1u"m/s", 1u"kg", 1u"kW"
(1.0 m/s, 1.0 kg, 1000.0 (m² kg)/s³)

julia> T = Union{typeof(x),typeof(y), typeof(z)}
Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}

julia> v = T[x,y,z]
3-element Vector{Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}}:
 1.0 m/s
 1.0 kg
 1000.0 (m² kg)/s³

julia> map(x->x*2, v)
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> map(x->x*2, [x,y,z])
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> collect(map(x->x*2, (x,y,z)))
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> vcat((map(x->x*2, (x,y,z)))...)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³





#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)


