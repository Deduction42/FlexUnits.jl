This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood


Current Tasks:
1.  For consistency with the ecosystem around Unitful, we will need to subtype Quantity to Number
<<<<<<< HEAD
    -   Remove MirrorDims and replace with the sentinel value approach (unknown(::Type{D}))
    -   Add specific "Array" multiplication/division ops with numeric quantities (check what Unitful.jl does)
=======
    -   Add specific "Array" multiplication/division ops with numeric quantities check Unitful.jl
>>>>>>> 4c3d4ff35b2db85bc39fc74d2a5c82b73a1d5e15
    -   See if we can get DifferentialEquations to work with this (Try it with Unitful first and identify missing features)
    -   Add typemin/typemax/one/onunit support for FixRat32 and make the sentinel value
        -   unknown(::Type{D}) where {T, D<:AbstractDimensions{T}} = D{T}(typemin(T)) the sentinel value
    -   Add paramerization of AffineTransform (so people can opt into Rational)
    -   Streamline promotions around FlexQuant and Quantity (and will likely need generalization)
    -   Auto-convert to dimensions only applies to StaticDims, but it really should apply to "*"
        -   Re-enforces consistency around the idea that "math operators" convert to dimensions
        -   Quantity/FlexQuant/quantity constructors shouldn't auto-convert

    Notes on MirrorDims replacement
        -   Use a sentinel value D(NaN) (FixedRational{B}(NaN) should set Numerator to typemin)
            -   StaticDims shoud NOT be allowed to use an unknown dimension (for equaldims type-stability)
        -   isknown(d::D) = (d!=D(NaN)) should cheap because it whould flag pretty quickly in most cases
        -   Create a function unknown(D) (called from zero, oneunit etc) which emits a warning the first time it's called
            -   WARNING: unkown dimension constructed (likely from oneunit(::Type) or zero(::Type)) results may be inaccurate or cause errors if used incorrectly
            -   This function is only applicable to DIMENSIONS (actual units needs to know the transform)
        -   Performance hit shouldn't be that severe
            -   equaldims(d1,d2) already needs a branch, just efficiently add more 
                -   May want to create a "select_unknown(d1,d2)" function that uses a branchless "ifelse" statement
            -   rawmul(d1,d2) and rawdiv(d1,d2) assume "isknown"; *(d1,d2) and /(d1,d2) return the unknown dimension
            -   actual multiplication should perform "rawmul" regardless, then use a branchless "ifelse" statement
                -   The only overhead is checking isknown on both dimensions 

3.  Build out documentation and a docs badge
    -   Remove MirrorDims 
    -   Add warnings around "Affine Delta" and "zero/oneunit"
    -   Add Examples
        -   The DynamicQ -> StaticQ -> DynamicQ (static intermediate) pattern with the PengRobinson benchmarks
        -   The unit dispatch pattern vs the static intermediate pattern
        -   DifferentialEquations if we can make them work
        -   Linear Dynamic System and Linear Algebra once added




Backlog:


2.  Finish basic LinmapQuant functionality for +,-,*,/,\,^,exp, (and matrix trigs)
    -   This consists of building shortcuts for UnitMap types
    -   Output should be the most specific form of unit mapping possible
    -   Make sure operations convert to LinmapQuant and output that type

    Notes on above:      
    -   Matrix multiplication is ONLY valid with LinmapQuant and will ALWAYS produce a LinmapQuant
        -   Multiplication should convert AbstractMatrix{Union{Quantity,NumberQuant}} to LinmapQuant
        -   This may result in more allocations, but is more reliable in pointing out errors
        -   It is recommendable to only store matrices as LinmapQuant if linear algebra is intended

3.  Add LinearAlgebra extensions for certain factorizations
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other transformations as well

4.  Add interactive unit functionality
    -   unit_index() (produces dict that lists all units for every dimension)
    -   simplify(q::Quantity{T,AbstractDimLike}) (lists all standard SI units, performs a greedy search to make units as terse as possible)
        e.g. simplify(1.0u"(m^2*kg)/s^3") = 1 kW


#Example of #3 is shown below

julia> using FlexUnits, .UnitRegistry

julia> (x, y, z) = 1u"m/s", 1u"kg", 1u"kW"
(1.0 m/s, 1.0 kg, 1000.0 (m² kg)/s³)

julia> T = Union{typeof(x),typeof(y), typeof(z)}
Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}

julia> v = T[x,y,z]
3-element Vector{Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}}:
 1.0 m/s
 1.0 kg
 1000.0 (m² kg)/s³

julia> map(x->x*2, v)
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> map(x->x*2, [x,y,z])
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> collect(map(x->x*2, (x,y,z)))
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> vcat((map(x->x*2, (x,y,z)))...)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³





#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)


