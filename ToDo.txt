This package should look like Unitful.jl but behave like DynamicQuantities.jl under the hood


Current Tasks:
1.  Build out documentation and a docs badge
    -   Include all-stops-out tutorial on defining a new dimension "RadDims"
    -   Add angle to the dimension list
    -   Create a new unit registry with that dimension 
    -   Re-tool sin, cos, tan rules on this particular dimension

    For documentation, add performance tips:
    1.  Avoid containers with mixed-static types, use dynamic units (can always convert using `udynamic`) if such a container exists 
        -   Dynanmic quantities are always type-stable and are less likely to result in performance-killing dynamic dispatch calls.
        -   Promotion rules will usually take care of this, but they're not always called by Julia
    2.  Use `q=dconvert(u"...", q0)` before performance-sensitive code if `q0` is a dynamic unit. 
        -   This function directly calculates a Quantity{T, StaticDims{D}} which is the highest-performance object at low-levels
        -   This has near zero overhead if "q0" is a dimensional quantity (only needs to verify dimension equality)
        -   When outputting results with different units, it's safest to convert back to dynamic quantities
    3.  Beware of calling "collect" and "map" on structures with mixed types, these functions don't properly promote arguments 
        (but `vcat` and `hcat` do, which is why using `[q1, q2, q3]` will work) (see example after backlog)


Backlog:
1.  Finish basic QuantLinMap functionality for +,-,*,/,\,^,exp, (and matrix trigs)
    -   This consists of building shortcuts for UnitMap types
    -   Output should be the most specific form of unit mapping possible
    -   Make sure operations convert to QuantLinMap and output that type

    Notes on above:      
    -   Matrix multiplication is ONLY valid with QuantLinMap and will ALWAYS produce a QuantLinMap
        -   Multiplication should convert both AbstractMatrix{Quantity} to QuantLinMap
        -   This may result in more allocations, but is more reliable in pointing out errors
        -   It is recommendable to only store matrices as QuantLinMap if linear algebra is intended

2.  Add LinearAlgebra extensions for certain factorizations
    -   cholesky (requries symmetric transform)
    -   eigen (confusing becasue it can use both idempotent and symmetric) 
        -   E' == inv(E) DOES NOT hold 
        -   For back-transformation, symmetric uses E' to produce inverse units, idempotent uses inv(E) produce same units
    -   consider other transformations as well

3.  Add interactive unit functionality
    -   unit_index() (produces dict that lists all units for every dimension)
    -   simplify(q::Quantity{T,AbstractDimLike}) (lists all standard SI units, performs a greedy search to make units as terse as possible)
        e.g. simplify(1.0u"(m^2*kg)/s^3") = 1 kW


#Example of #3 is shown below

julia> using FlexUnits, .UnitRegistry

julia> (x, y, z) = 1u"m/s", 1u"kg", 1u"kW"
(1.0 m/s, 1.0 kg, 1000.0 (m² kg)/s³)

julia> T = Union{typeof(x),typeof(y), typeof(z)}
Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}

julia> v = T[x,y,z]
3-element Vector{Union{Quantity{Float64, StaticDims{m/s}}, Quantity{Float64, StaticDims{kg}}, Quantity{Float64, StaticDims{(m² kg)/s³}}}}:
 1.0 m/s
 1.0 kg
 1000.0 (m² kg)/s³

julia> map(x->x*2, v)
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> map(x->x*2, [x,y,z])
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> collect(map(x->x*2, (x,y,z)))
3-element Vector{Quantity{Float64}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³

julia> vcat((map(x->x*2, (x,y,z)))...)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
 2.0 m/s
 2.0 kg
 2000.0 (m² kg)/s³





#====================================================================================================
Some benchmarks
====================================================================================================#
import DynamicQuantities
import Unitful
using BenchmarkTools

v1flex = ubase.([1u"m/s", 1u"J/kg", 1u"A/V"])
v1uni  = [1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V"]
v1dyn  = [1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V"]

@btime sum(x->x^0.0, v1uni)
@btime sum(x->x^0.0, v1flex)
@btime sum(x->x^0.0, v1dyn)

t1flex = ubase.((1u"m/s", 1u"J/kg", 1u"A/V"))
t1uni  = (1*Unitful.u"m/s", 1*Unitful.u"J/kg", 1*Unitful.u"A/V")
t1dyn  = (1*DynamicQuantities.u"m/s", 1*DynamicQuantities.u"J/kg", 1*DynamicQuantities.u"A/V")

@btime sum(x->x^0, t1uni)
@btime sum(x->x^0, t1flex)
@btime sum(x->x^0, t1dyn)


