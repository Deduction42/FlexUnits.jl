<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Performance · FlexUnits.jl</title><meta name="title" content="Performance · FlexUnits.jl"/><meta property="og:title" content="Performance · FlexUnits.jl"/><meta property="twitter:title" content="Performance · FlexUnits.jl"/><meta name="description" content="Documentation for FlexUnits.jl."/><meta property="og:description" content="Documentation for FlexUnits.jl."/><meta property="twitter:description" content="Documentation for FlexUnits.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexUnits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Performance</a><ul class="internal"><li><a class="tocitem" href="#Why-FlexUnits-is-fast"><span>Why FlexUnits is fast</span></a></li><li><a class="tocitem" href="#Why-FlexUnits-is-efficient-at-linear-algebra"><span>Why FlexUnits is efficient at linear algebra</span></a></li><li><a class="tocitem" href="#Performance-Tips"><span>Performance Tips</span></a></li></ul></li><li><a class="tocitem" href="../manipulation/">Unit Manipulation</a></li><li><a class="tocitem" href="../linearalgebra/">Linear Algebra</a></li><li><a class="tocitem" href="../examples/">Advanced Examples</a></li><li><a class="tocitem" href="../types/">Types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Performance</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Performance</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Deduction42/FlexUnits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Deduction42/FlexUnits.jl/blob/main/docs/src/performance.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h1><h2 id="Why-FlexUnits-is-fast"><a class="docs-heading-anchor" href="#Why-FlexUnits-is-fast">Why FlexUnits is fast</a><a id="Why-FlexUnits-is-fast-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FlexUnits-is-fast" title="Permalink"></a></h2><p>FexUnits.jl combines techniques from Unitful.jl on &quot;static units&quot; to obtain near zero overhead performance when units can be resolved at parse time, but falls back to &quot;dynamic unit&quot; methods used by DynamicQuantities.jl if units cannot be inferred at parse time. This is done through promotion rules which convert static-dimension quantities to dynamic-dimension quantities if different dimensions are present. This retains the high-performance behaviour of Unitful.jl when units are known at compile time, but often falls back to the performance of DynanicQuantity.jl if they can&#39;t be inferred. In the first set of benchmarks, we see that FlexUnits.jl and DynamicQuantities.jl vastly outperform Unitful.jl (by more than 100x) when units cannot be inferred.</p><pre><code class="language-julia hljs">using FlexUnits
using .UnitRegistry
import DynamicQuantities
import Unitful
using BenchmarkTools

v1uni  = [1.0*Unitful.u&quot;m/s&quot;, 1.0*Unitful.u&quot;J/kg&quot;, 1.0*Unitful.u&quot;A/V&quot;]
v1dyn  = [1.0*DynamicQuantities.u&quot;m/s&quot;, 1.0*DynamicQuantities.u&quot;J/kg&quot;, 1.0*DynamicQuantities.u&quot;A/V&quot;]
v1flex = [1.0u&quot;m/s&quot;, 1.0u&quot;J/kg&quot;, 1.0u&quot;A/V&quot;]

@btime sum(x-&gt;x^0.0, $v1uni)
  8.100 μs (86 allocations: 3.92 KiB)
@btime sum(x-&gt;x^0.0, $v1dyn)
  41.717 ns (0 allocations: 0 bytes)
@btime sum(x-&gt;x^0.0, $v1flex)
  5.300 ns (0 allocations: 0 bytes)</code></pre><p>In the second example, we see that FlexUnits.jl and Unitful.jl outperform DynanicQuantities.jl when units can be inferred by the compiler.</p><pre><code class="language-julia hljs">t1uni  = [1.0*Unitful.u&quot;m/s&quot;, 1.0*Unitful.u&quot;m/s&quot;, 1.0*Unitful.u&quot;m/s&quot;]
t1dyn  = [1.0*DynamicQuantities.u&quot;m/s&quot;, 1.0*DynamicQuantities.u&quot;m/s&quot;, 1.0*DynamicQuantities.u&quot;m/s&quot;]
t1flex = [1.0u&quot;m/s&quot;, 1.0u&quot;m/s&quot;, 1.0u&quot;m/s&quot;]

@btime sum(x-&gt;x^2, $t1uni)
  3.000 ns (0 allocations: 0 bytes)
@btime sum(x-&gt;x^2, $t1dyn)
  7.407 ns (0 allocations: 0 bytes)
@btime sum(x-&gt;x^2, $t1flex)
  3.000 ns (0 allocations: 0 bytes)</code></pre><p>While this performance boost over DynamicQuantities.jl isn&#39;t as dramatic as the previous boost over Unitful.jl, it is still significant. In most benchmarks (examples can be found in the test folder of the FlexUnits repo) FlexUnits matches the best performing alternative (DynamicQuantities or Unitful). There are two notable exceptions:</p><ol><li>FlexUnits.jl is slightly slower than Unitful.jl at <code>uconvert</code>, but still much faster than DynamicQuantities.jl</li><li>FlexUnits.jl can be significantlhy faster than both Unitful.jl and DynamicQuantities.jl for iterative statically-inferred algorithms where unitful values are reassigned (Unitful tends to overspecialize but the FlexUnits design avoids this)</li></ol><h2 id="Why-FlexUnits-is-efficient-at-linear-algebra"><a class="docs-heading-anchor" href="#Why-FlexUnits-is-efficient-at-linear-algebra">Why FlexUnits is efficient at linear algebra</a><a id="Why-FlexUnits-is-efficient-at-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FlexUnits-is-efficient-at-linear-algebra" title="Permalink"></a></h2><p>In order for matrix multiplication and other linear algebra operations to be possible, the units need to be consistent. In order to be consistent, the matrix must be constructed to take a vector with units <code>u_in</code> and produce a vector of units <code>u_out</code>. To do this, the units of an entire N×M matrix can be described by the following factorization</p><ul><li>A scalar dimension factor <code>u_fact</code></li><li>An M-1 vector of input units <code>u_in</code></li><li>An N-1 vector of output units <code>u_out</code></li></ul><p>This results in a matrix being described by N+M-1 values instead of NxM, this can result in a significant amount of compressions. Addiitonally, these factored units are stored separately from the matrix of numerical values. This factorization and separation provides the two main benefits:</p><ol><li>Efficient, well-tested, pure-numerical matrix operations can be performed on the raw numerical values</li><li>Unit dimensions can be solved using efficient O(N) methods on DimsMap objects which only store (M+N+1) values instead of (M×N) values (DimsMap stores two more values than the bare-minimum for validation purposes).</li></ol><p>These efficiency gains means that even if units must be dynamic (due to different units in the array), the overhead of resolving these units can be minimal. Let&#39;s compare mixed-unit matrix multiplication with differnt packages.</p><h3 id="Matrix-Multiplication-Benchmarks"><a class="docs-heading-anchor" href="#Matrix-Multiplication-Benchmarks">Matrix Multiplication Benchmarks</a><a id="Matrix-Multiplication-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Multiplication-Benchmarks" title="Permalink"></a></h3><p>The first example consists of multiplying a 200x4 matrix by a 4x4 matrix</p><pre><code class="language-julia hljs">#Use unitless matrices as a benchmark
Nr = 200
X = randn(Nr, 4)
M = rand(4,4)

#Construct unitful matrices
uu = [Unitful.u&quot;kg/s&quot;, Unitful.u&quot;kW&quot;, Unitful.u&quot;rad/s&quot;, Unitful.u&quot;N/m&quot;]
ut = reshape(uu, 1, :)
Xu = X.*ut
Mu = inv.(uu) .* M .* inv.(ut)

#Construct DynamicQuantity matrices
udq = [DynamicQuantities.u&quot;kg/s&quot;, DynamicQuantities.u&quot;kW&quot;, DynamicQuantities.u&quot;rad/s&quot;, DynamicQuantities.u&quot;N/m&quot;]
udqt = reshape(udq, 1, :)
Xdq = X.*udqt
Mdq = inv.(udq) .* M .* inv.(udqt)

#Construct LinmapQuant matrices
ufq = [UnitRegistry.u&quot;kg/s&quot;, UnitRegistry.u&quot;kW&quot;, UnitRegistry.u&quot;rad/s&quot;, UnitRegistry.u&quot;N/m&quot;]
Xfq = LinmapQuant(X, UnitMap(u_out = UnitRegistry.u&quot;&quot;, u_in = inv.(ufq)))
Mfq = LinmapQuant(M, UnitMap(u_out = inv.(ufq), u_in=ufq))


julia&gt; @btime X*M #No units
  700.000 ns (3 allocations: 6.35 KiB)

julia&gt; @btime Xu*Mu #Unitful, more than 500x slower
  395.700 μs (5603 allocations: 93.83 KiB)

julia&gt; @btime Xdq*Mdq #DynamicQuantities, about 8x slower
  5.700 μs (3 allocations: 31.34 KiB)

julia&gt; @btime Xfq*Mfq #LinmapQuant, almsot no overhead
  710.000 ns (4 allocations: 6.41 KiB)</code></pre><p>The main reason why FlexUnits.jl has nearly no overhead is that only the inner product of the units between matrices is considered. Only the first 4-element row of X and the first column of M need to be compared. Unit inference does not touch the other 199 rows of X or the other 3 colums of M.</p><h3 id="Linear-Regression-Benchmarks"><a class="docs-heading-anchor" href="#Linear-Regression-Benchmarks">Linear Regression Benchmarks</a><a id="Linear-Regression-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Regression-Benchmarks" title="Permalink"></a></h3><p>Linear regression benchmarks can only be compared between FlexUnits and the raw numerical methods. Neither Unitful.jl nor DynamicQuantities.jl can handle matrix inversions.</p><pre><code class="language-julia hljs">julia&gt; Mu/Mu #Unitful fails at &#39;oneunit&#39;
ERROR: MethodError: no method matching oneunit(::Type{Any})
This error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.

julia&gt; Mdq/Mdq #DynamicQuantities also fails at &#39;oneunit&#39;
ERROR: Cannot create a dimensionful 1 from `Type{DynamicQuantities.Quantity}` without knowing the dimensions. Please use `oneunit(::DynamicQuantities.Quantity)` instead.

julia&gt; collect(Mfq)/collect(Mfq) #Matrices of FlexUnit quantities fails further down becuase LU-factorization logic eventually compares quantities of different units
ERROR: DimensionError: (s²/kg², s⁴/(m² kg²)) have incompatible dimensions

julia&gt; Mfq/Mfq #FlexUnits LinmapQuant matrices actually work
4×4 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
          1.0           0.0 m²/s²                 0.0 1/kg           -0.0 1/s
     0.0 s²/m²               1.0   -3.29362e-21 s²/(m² kg)  -2.75549e-20 s/m²
        0.0 kg     0.0 (m² kg)/s²                     1.0           -0.0 kg/s
 6.32944e-16 s  -6.10423e-13 m²/s         2.87226e-16 s/kg               1.0</code></pre><p>We can use linear algebra to complete the linear regression as follows:</p><pre><code class="language-julia hljs">Nr = 200
XY = randn(Nr, 6) * rand(6, 6)
X = [XY[:, begin:4] ones(Nr)]
Y = XY[:, 5:end]
Xu = LinmapQuant(X, UnitMap(u_out=UnitRegistry.u&quot;&quot;, u_in=inv.([UnitRegistry.u&quot;kg/s&quot;, UnitRegistry.u&quot;kW&quot;, UnitRegistry.u&quot;rad/s&quot;, UnitRegistry.u&quot;N/m&quot;, UnitRegistry.u&quot;&quot;])))
Yu = LinmapQuant(Y, UnitMap(u_out=UnitRegistry.u&quot;&quot;, u_in=inv.([UnitRegistry.u&quot;K&quot;, UnitRegistry.u&quot;kPa&quot;])))

julia&gt; @btime (X&#39;X)\(X&#39;Y) #No units
  4.880 μs (12 allocations: 992 bytes)

julia&gt; @btime Bu = (Xu&#39;Xu)\(Xu&#39;Yu) #LinmapQuant, about 1.3x slower
  6.400 μs (19 allocations: 1.66 KiB)</code></pre><p>This time, the overhead from unit inference was noticeable, but still much less than 2x. The reason for this is because <code>Xu&#39;*Xu</code> is a long multiplication that compares the 200 columns of <code>Xu&#39;</code> vs the 200 rows of <code>Xu</code>, with the same thing happening again in <code>Xu&#39;*Yu</code>. Thankfully, this 200-row comparison is required only once for the 25 combinations of <code>Xu&#39;*Xu</code> and once for the 10 combinations of <code>Xu&#39;*Yju</code>. In general, unit inference is about 6x to 8x slower than floating-point operations, so having two unit inferences for every 35 floating-point operations gives a slowdown factor of (35+2*7)/35 = 1.4, almost exactly the slowdown that was seen in the benchmarks.</p><h2 id="Performance-Tips"><a class="docs-heading-anchor" href="#Performance-Tips">Performance Tips</a><a id="Performance-Tips-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Tips" title="Permalink"></a></h2><p>While FlexUnits is generally fast, there are a few things one may need to watch out for to get the most out of this package.</p><h3 id="1.-Avoid-containers-with-mixed-static-unit-types,-use-dynamic-units-instead"><a class="docs-heading-anchor" href="#1.-Avoid-containers-with-mixed-static-unit-types,-use-dynamic-units-instead">1. Avoid containers with mixed static-unit types, use dynamic units instead</a><a id="1.-Avoid-containers-with-mixed-static-unit-types,-use-dynamic-units-instead-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Avoid-containers-with-mixed-static-unit-types,-use-dynamic-units-instead" title="Permalink"></a></h3><p>A great deal of the work done in this package was devoted to building a performant type-stable dynamic unit/dimension system that can represent many different unit types and promotion rules that avoid mixed-type containers. While promotion rules help, some Julia functions don&#39;t apply conversion (this includes <code>collect</code> and <code>map</code>, but <code>vcat(...)</code> reliably promotes); if such mixed-type containers occur, use <code>udynamic</code> to explicitly convert static units to dynamic ones.</p><h3 id="2.-Use-dynamic-units-for-high-level-code"><a class="docs-heading-anchor" href="#2.-Use-dynamic-units-for-high-level-code">2. Use dynamic units for high-level code</a><a id="2.-Use-dynamic-units-for-high-level-code-1"></a><a class="docs-heading-anchor-permalink" href="#2.-Use-dynamic-units-for-high-level-code" title="Permalink"></a></h3><p>Dynanmic quantities are always type-stable and are less likely to result in accidental performance-killing dynamic dispatch calls. This is increasingly important if you want to produce small static binaries with Julia because dynamic dispatch can inhibit this. Using dynamic units can also prevent long compile times as it reduces specialization.</p><h3 id="3.-Use-LinmapQuant/VectorQuant-for-linear-algebra"><a class="docs-heading-anchor" href="#3.-Use-LinmapQuant/VectorQuant-for-linear-algebra">3. Use LinmapQuant/VectorQuant for linear algebra</a><a id="3.-Use-LinmapQuant/VectorQuant-for-linear-algebra-1"></a><a class="docs-heading-anchor-permalink" href="#3.-Use-LinmapQuant/VectorQuant-for-linear-algebra" title="Permalink"></a></h3><p>These representations allow the use of optimized numerical methods for linear algebra, and employ shortcuts to solve the units of the matrix separately. This is especially important for large matrices. If input values are already numerical matrices, constructors for <code>LinmapQuant</code> are more efficient at <em>attaching units</em> to said vectors, as only N+M+1 dimension values are stored instead of the full M×N.</p><h3 id="4.-Pay-attention-to-the-output-types-of-linear-algebra-operations"><a class="docs-heading-anchor" href="#4.-Pay-attention-to-the-output-types-of-linear-algebra-operations">4. Pay attention to the output types of linear algebra operations</a><a id="4.-Pay-attention-to-the-output-types-of-linear-algebra-operations-1"></a><a class="docs-heading-anchor-permalink" href="#4.-Pay-attention-to-the-output-types-of-linear-algebra-operations" title="Permalink"></a></h3><p>If a shortcut method is implemented, the output should be either a <code>LinmapQuant</code> or a <code>VectorQuant</code>. Otherwise a slower fallback method has been used. If this happens where not expected, please submit a bug report. It is likely that a method has been overlooked.</p><h3 id="5.-Use-dconvert-to-transition-from-dynamic-units-to-static-units-in-low-level-code"><a class="docs-heading-anchor" href="#5.-Use-dconvert-to-transition-from-dynamic-units-to-static-units-in-low-level-code">5. Use <code>dconvert</code> to transition from dynamic units to static units in low-level code</a><a id="5.-Use-dconvert-to-transition-from-dynamic-units-to-static-units-in-low-level-code-1"></a><a class="docs-heading-anchor-permalink" href="#5.-Use-dconvert-to-transition-from-dynamic-units-to-static-units-in-low-level-code" title="Permalink"></a></h3><p>Dynamic units are great for achieving effortless type stability, but static units really shine in performance-sensitive low-level code where there&#39;s a small number of variables with known dimensions. In such cases, one can simply use <code>dconvert(u&quot;...&quot;, q)</code> to convert <code>q</code> to a quantity with the same dimensions as <code>u</code>. Because most of the calcualtion is done using dimensional quantities, no conversion math needs to take place, one simply needs to verify that the units match, thus <code>dconvert</code> has very little overhead.</p><h3 id="6.-Use-vcat-or-some-other-promoting-method-to-transition-from-low-level-code-to-high-level-code"><a class="docs-heading-anchor" href="#6.-Use-vcat-or-some-other-promoting-method-to-transition-from-low-level-code-to-high-level-code">6. Use <code>vcat</code> or some other promoting method to transition from low-level code to high-level code</a><a id="6.-Use-vcat-or-some-other-promoting-method-to-transition-from-low-level-code-to-high-level-code-1"></a><a class="docs-heading-anchor-permalink" href="#6.-Use-vcat-or-some-other-promoting-method-to-transition-from-low-level-code-to-high-level-code" title="Permalink"></a></h3><p>As mentioned before, some functions like <code>collect</code> and <code>map</code> don&#39;t use <code>promote</code>. However, other methods like explicit vector construction like <code>v=[x,y,z]</code> and using <code>vcat</code> on splatted tuples properly trigger <code>promote</code>. When returning containers with multiple units, make sure they are properly promoted to dynamic units, otherwise overspecialization and dynanmic calls may leak to other parts of your code.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../manipulation/">Unit Manipulation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 00:36">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
