var documenterSearchIndex = {"docs":
[{"location":"linearalgebra/#Linear-Algebra","page":"Linear Algebra","title":"Linear Algebra","text":"FlexUnits provides broader support for mixed-unit operations than other packages to date. This is done in to major ways:\n\nUsing a sentinel value to denote unknown dimensions and yield a one-time bypass to unit checking\nFactoring units with LinmapQuant object to separate matrices from units, and provide shortcut methods to infer units on various operations","category":"section"},{"location":"linearalgebra/#Unknown-Dimensions","page":"Linear Algebra","title":"Unknown Dimensions","text":"","category":"section"},{"location":"linearalgebra/#Much-of-Julia-codebase-breaks-when-dimensions-are-unknown","page":"Linear Algebra","title":"Much of Julia codebase breaks when dimensions are unknown","text":"Much of the core Julia ecosystem relies the pattern of initializing values with zero(T::Number), initializing matrices with zeros or even accessing zero elements in a sparse array. This works when the dimensions are statically known, but fails when they are not.\n\njulia> Diagonal(randn(3).*Unitful.u\"m/s\")[1,2] #Unitful.jl works when units are statically known\n0.0 m s^-1\n\njulia> Diagonal(randn(3).*[Unitful.u\"m/s\", Unitful.u\"kg/hr\", Unitful.u\"kW\"])[1,2] #Unitful.jl fails when units are not statically known\nERROR: ArgumentError: zero(Unitful.Quantity{Float64}) not defined.\n\njulia> Diagonal(randn(3).*DynamicQuantities.u\"m/s\")[1,2] #DynamicQuantities works because it factors this out as a QuantityArray\n0.0 m s⁻¹\n\njulia> Diagonal(randn(3).*[DynamicQuantities.u\"m/s\", DynamicQuantities.u\"kg/hr\", DynamicQuantities.u\"kW\"]) #DynamicQuantities won't let you build a Diagonal matrix with different dimensions\nERROR: DimensionError: -0.18627823028424698 m s⁻¹ and DynamicQuantities.Quantity{Float64, DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}}[-0.18627823028424698 m s⁻¹, -0.00021716734256511895 kg s⁻¹, -262.81003984968476 m² kg s⁻³] have incompatible dimensions\n\njulia> sparse([1,2,3], [1,2,3], [DynamicQuantities.u\"m/s\", DynamicQuantities.u\"kg/hr\", DynamicQuantities.u\"kW\"])[1,2] #Sparse results in same problem as Unitful\nERROR: Cannot create an additive identity from `Type{<:DynamicQuantities.Quantity}`, as the dimensions are unknown. Please use `zero(::DynamicQuantities.Quantity)` instead.","category":"section"},{"location":"linearalgebra/#FlexUnits-provides-an-unknown-dimension","page":"Linear Algebra","title":"FlexUnits provides an unknown dimension","text":"FlexUnits works like Unitful when units are statically known, but when they are not, a sentinel value is used to denote unknown dimensions. This is done by setting every dimension element to its typemax value (which is a very improbable value of 2147483647//25200 for the default FixRat32 type). Unknown dimensions are displayed as ?/?\n\njulia> Diagonal(randn(3).*u\"m/s\")[1,2] #FlexUnits correctly returns unitful result when units are statically known\n0.0 m/s\n\njulia> Diagonal(randn(3).*[u\"m/s\", u\"kg/hr\", u\"kW\"])[1,2] #FlexUnits returns an object with unknown dimensions \n0.0 ?/?\n\njulia> Diagonal(randn(3).*[u\"m/s\", u\"kg/hr\", u\"kW\"])[1,2] + 5u\"m/s\" #Unit-validating operations like '+' bypass unit validation once\n5.0 m/s\n\nThis solves the \"additive identity\" problem mentioned in the DynamicQuantities error. In general, operations that change dimensions (like multiplication, division, and exponentiation) propagate the unknown dimension flag value, while operations that validate units (addition, subtraction, max/min) will return a known dimension.\n\njulia> zero(Quantity{Float64, Dimensions{FixRat32}}) #zero produces unknown units when fed a type\n0.0 ?/?\n\njulia> zero(Quantity{Float64, Units{Dimensions{FixRat32},AffineTransform{Float64}}}) #zero only works on dimensional quantities\nERROR: ArgumentError: This operation only supports dimensional quantities\n\njulia> oneunit(Quantity{Float64, Dimensions{FixRat32}}) * 5u\"kW\" #Unknown dimensions propagate through multiplication, values are scaled to SI\n5000.0 ?/?\n\njulia> max(500*oneunit(Quantity{Float64, Dimensions{FixRat32}}), 2u\"J\") #Comparison is done on the SI scale and returns known units\n500.0 (m² kg)/s²","category":"section"},{"location":"linearalgebra/#Mitigating-risks-of-silently-wrong-results","page":"Linear Algebra","title":"Mitigating risks of silently wrong results","text":"One potential issue for unkown dimensions is the ability to silently retrun the wrong results. The main way this is mitigated is to only support unknown values on raw dimensions. Since all dimensional units (like SI) can be converted to each other without any scaling factors, the scale numerical results will always be consistent. The only kind of error that can happen is a wrongly bypassed dimensional validation. Since validation can only be bypassed once, initializers (which predate validation) are not going to be an issue.\n\njulia> zero(Quantity{Float64, Dimensions{FixRat32}}) + 3u\"km/hr\" #This makes sense, initializer is ignorant\n0.8333333333333334 m/s\n\njulia> zero(Quantity{Float64, Dimensions{FixRat32}}) + 3u\"km/hr\" + 2u\"kg\" #Incorrect operations still get flagged\nERROR: DimensionError: (m/s, kg) have incompatible dimensions\n\njulia> julia> Diagonal([1u\"m/s\", 1u\"kg\", 1u\"mol\"])*(ones(3).*u\"s\") #Matrix multiplication naturally works\n3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:\n       1.0 m\n  1.0 (kg s)\n 1.0 (s mol)\n\nThe main risk is therefor accidentally deleting known unit information. As seen in the eample above, this doesn't happen as long as the units are full-rank. Issues can still happen with very sparse matrices through, and results clearly show that unknown dimensions are present.\n\njulia> sparse([1,3], [1,3], [1u\"m/s\", 1u\"mol\"])*(ones(3).*u\"s\")\n3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:\n       1.0 m\n     0.0 ?/?\n 1.0 (s mol)\n\nWhen matrices are this sparse, unkown dimensions in the result are understandable. However if the position in the matrix can be associated with a dimension, this problem can be solved by wrapping the numerical sparse matrix inside a LinmapQuant (explained in the next subsection). \n\nThe other risk from unknown dimensions is confusion between one and oneunit\n\njulia> one(Quantity{Float64, Dimensions{FixRat32}}) * 2u\"A\" #Calling 'one' maintains unit information\n2.0 A\n\njulia> oneunit(Quantity{Float64, Dimensions{FixRat32}}) * 2u\"A\" #Calling 'oneunit' deletes unit information\n2.0 ?/?\n\nCareful understanding of the nuances between these two functions should be acquired before attempting to use these functions. Even with this potential for confusion, when testing against common Julia functions and patterns, introducing unkown dimensions solves far more problems than it creates.","category":"section"},{"location":"linearalgebra/#Unit-Factorization","page":"Linear Algebra","title":"Unit Factorization","text":"","category":"section"},{"location":"linearalgebra/#DimsMap-factorization-compresses-the-units-as-a-mapping","page":"Linear Algebra","title":"DimsMap factorization compresses the units as a mapping","text":"In order for matrix multiplication and other linear algebra operations to be possible, the units need to be consistent. In order to be consistent, the matrix must be constructed to take a vector with units u_in and produce a vector of units u_out. To do this, the units of an entire N×M matrix can be described by the following factorization as a DimsMap\n\nA scalar dimension factor u_fac\nAn M-1 vector of input units u_in\nAn N-1 vector of output units u_out\n\nThe internal object DimsMap represents this factorization into base units (although it uses N and M vectors and forces the first element to be dimensionless).","category":"section"},{"location":"linearalgebra/#LinmapQuant-separates-unit-factorization-from-the-numbers","page":"Linear Algebra","title":"LinmapQuant separates unit factorization from the numbers","text":"The LinmapQuant object separates a numerical matrix from a DimsMap. For vectors, the VectorQuant object simply has a vector of numbers and a vector of base units. This separation provides the following benefits:\n\nEfficient, well-tested, pure-numerical matrix operations can be performed on the raw numerical values\nUnit dimensions can be solved using efficient O(N) methods on DimsMap objects which only store (M+N+1) values instead of (M×N) values\n\nThus, in order to perform a matrix operation, one simply performs the operations on the pure numerical values, and then perform the accelerated counterpart operation on the DimsMap.","category":"section"},{"location":"linearalgebra/#Constructor-Examples","page":"Linear Algebra","title":"Constructor Examples","text":"The easiest way to construct a LinmapQuant is to construct a UnitMap and multiply it to a matrix or use the constructor. UnitMap is generic and allows for units or dimensions.\n\nX = randn(20, 5)*rand(5,5)\n\n#Make sure to invert u_in if you want to assign units directly\njulia> X * UnitMap(u_in=inv.([u\"K\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out=fill(u\"\", size(X,1))) \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:\n  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A\n -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A\n\n#Scalar arguments are repeated along the dimension for convenience\njulia> X * UnitMap(u_in=inv.([u\"K\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out=u\"\") \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:\n  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A\n -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A\n\n#Affine units can be used inside a UnitMap\njulia> UnitMap(u_in=[u\"°C\", u\"km\", u\"mol\", u\"kg\", u\"A\"], u_out=u\"\") \nUnitMap{Units{Dimensions{FixRat32}, AffineTransform{Float64}}, Vector{Units{Dimensions{FixRat32}, AffineTransform{Float64}}}, Units{Dimensions{FixRat32}, AffineTransform{Float64}}}(Units{Dimensions{FixRat32}, AffineTransform{Float64}}[°C, km, mol, kg, A], )\n\n#Affine units cannot be used for a DimsMap however\njulia> X * UnitMap(u_in=inv.([u\"°C\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out=u\"\") \nERROR: NotScalarError: °C cannot be treated as scalar, operation only valid for scalar units\n\nUsing UnitMap will create a modified matrix (ensuring all values are dimensional). For more efficiency, one can use DimsMap, which won't allocate a new array, but this object has stricter requirements. DimsMap only accepts vector arguments (which must be appropriately sized), and only dimensional units (i.e. SI) can be used (so that the matrix of numbers is not modified).\n\n#DimsMap is more efficient (doens't reallocate X) but is fussier\njulia> X * DimsMap(u_in=inv.([u\"K\", u\"m\", u\"mol\", u\"kg\", u\"A\"]), u_out=fill(u\"\", size(X,1))) \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:\n  0.423785 K     1.44668 m   1.43043 mol   0.271962 kg    2.35996 A\n -0.601045 K    0.150874 m  0.608505 mol  -0.146254 kg   0.509313 A\n\n#Vector inputs are required\njulia> X * DimsMap(u_in=inv.([u\"K\", u\"m\", u\"mol\", u\"kg\", u\"A\"]), u_out=u\"\") \nERROR: MethodError: no method matching DimsMap(::Nothing, ::Vector{Units{Dimensions{…}, AffineTransform{…}}}, ::StaticUnits{, AffineTransform{Float64}})\n\n#Units must be dimensional (i.e. SI)\njulia> X * DimsMap(u_in=inv.([u\"K\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out=fill(u\"\", size(X,1))) \nERROR: ArgumentError: 'u_in' argument must directly map to dimensions Dimensions{FixRat32}[1/K, 1/m, 1/mol, 1/kg, 1/A] without scaling\n\nMultiplication is simply shorthand for the LinmapQuant constructor that can also be used\n\n#You can also use LinmapQuant constructor\njulia> LinmapQuant(X, UnitMap(u_in=inv.([u\"K\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out=u\"\")) \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:\n  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A\n -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A","category":"section"},{"location":"linearalgebra/#Optimizations-and-pitfalls","page":"Linear Algebra","title":"Optimizations and pitfalls","text":"The goal is to optimize all possible linear algebra opterations on matrices that can be found in LinearAlgebra. However, some operations might resort to unoptimized fallbacks, particularly if a an optimized function or matrix type hasn't been implemented yet. The general rule is that if the operation returns a \"LinmapQuant\" or \"VectorQuant\", it has been optimized. As of the current release, matrix operators should optimized.\n\nX = (randn(20, 5)*randn(5,5)) * UnitMap(u_in=inv.([u\"K\", u\"km\", u\"mol\", u\"kg\", u\"A\"]), u_out = u\"\")\n\n#Adjoints of LinmapQuant should work\njulia> X'*X \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n      91.9205 K²    41503.5 (m K)    -36.038 (K mol)     109.162 (kg K)   -40.1446 (A K)\n   41503.5 (m K)      2.7836e7 m²    3810.33 (m mol)     57686.8 (m kg)   -19885.5 (m A)\n\n#Multiplications with unoptimized matrices should return an optimized version\njulia> collect(X')*X \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n      91.9205 K²    41503.5 (m K)    -36.038 (K mol)     109.162 (kg K)   -40.1446 (A K)\n   41503.5 (m K)      2.7836e7 m²    3810.33 (m mol)     57686.8 (m kg)   -19885.5 (m A)\n\n#Inversions should work\njulia> inv(collect(X')*X) \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n        0.595211 1/K²     0.000584858 1/(m K)    0.00165344 1/(K mol)     -0.66111 1/(kg K)       0.14344 1/(A K)\n  0.000584858 1/(m K)         2.23064e-6 1/m²  -0.000378828 1/(m mol)  -0.00129237 1/(m kg)   0.000471164 1/(m A)\n\n#Matrix divisions should work\njulia> (X'*X)\\(X'*X) \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n               1.0     -1.79517e-13 m/K    3.46556e-15 mol/K    8.31693e-16 kg/K     3.71834e-15 A/K\n    1.83657e-17 K/m                1.0     4.06306e-18 mol/m   -2.30576e-19 kg/m     4.72759e-18 A/m\n\n#Matrix divisions should work if denominator is optimized\njulia> collect((X'*X))/(X'*X) \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n              1.0     1.83657e-17 K/m  -2.07142e-15 K/mol    -1.40926e-14 K/kg    4.03822e-15 K/A\n  -1.79517e-13 m/K               1.0   -2.13253e-14 m/mol      1.1747e-13 m/kg           -0.0 m/A\n\n#Addition/Subtraction with unoptimized matrices should work\njulia> collect(X) + X \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n    7.2873 K   823.543 m   -7.70232 mol    6.54604 kg  -2.10165 A\n   5.14641 K   2081.26 m   -7.58251 mol    5.00889 kg  -6.87539 A\n\n#Matrix powers will work if output units are similar to input units (can differ by a factor)\njulia> ((X'*X)\\(X'*X)*u\"s\")^2 \n5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n                  1.0 s²    -3.59033e-13 (m s²)/K    6.93113e-15 (s² mol)/K    1.66339e-15 (kg s²)/K     7.43669e-15 (s² A)/K\n    3.67315e-17 (s² K)/m                   1.0 s²    8.12611e-18 (s² mol)/m   -4.61153e-19 (kg s²)/m     9.45517e-18 (s² A)/m\n\nBroadcasting should work, but unfortunately, will not be optimized unless both values are a LinmapQuant. This is becuase broadcasting operations do not require both matrices to be proper linear mappings, and multiplication with a generic matrix can destroy this property.\n\n#Broadcasted operations will maintain factorization if all arguments are factorized\njulia> X .* X \n20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:\n   13.2762 K²  1.69556e5 m²     14.8314 mol²    10.7127 kg²   1.10423 A²\n   6.62139 K²  1.08291e6 m²     14.3736 mol²    6.27226 kg²   11.8177 A²\n\n#Factorization is lost with broadcasting if any argument is not factorized (observe the Matrix return type)\njulia> X .* collect(X) \n20×5 Matrix{Quantity{Float64, Dimensions{FixRat32}}}:\n   13.2762 K²  1.69556e5 m²     14.8314 mol²    10.7127 kg²   1.10423 A²\n   6.62139 K²  1.08291e6 m²     14.3736 mol²    6.27226 kg²   11.8177 A²","category":"section"},{"location":"linearalgebra/#Factored-Unit-Shortcuts","page":"Linear Algebra","title":"Factored Unit Shortcuts","text":"Shortcut tricks for factored units exist for many different matrix types and operations. More will likely be discovered and added in the future.","category":"section"},{"location":"linearalgebra/#DimsMap-Matrix-Multiplication","page":"Linear Algebra","title":"DimsMap Matrix Multiplication","text":"To solve the DimsMap problem for matrix multiplication m*n, one simply has to perform these steps:\n\nEnsure that u_in for m is the inverse of the u_out for n (an O(N) operation)\nMultiply the u_fac values of both matrices (an O(1) operation)\nConstruct a new DimsMap object with the u_out for m, the u_in for n and the u_fac from step 2\n\nThe entire DimsMap solution is O(N) where N is the number of columns in m.","category":"section"},{"location":"linearalgebra/#DimsMap-Matrix-Inversion","page":"Linear Algebra","title":"DimsMap Matrix Inversion","text":"To solve the DimsMap problem for a matrix inversion of m, one simplyh has to perform these steps:\n\nInvert the u_fac for m (an O(1) operation)\nConstruct a new DimsMap object from the u_fac result in step 1 and swapping the u_in and u_out vectors (an O(1) operation)\n\nThe entire DimsMap solution in this case is O(1)","category":"section"},{"location":"linearalgebra/#DimsMap-Matrix-Powers","page":"Linear Algebra","title":"DimsMap Matrix Powers","text":"Only certain unit structures can be raised to a power, because in order for an m*n multiplication to work the input units of m must be dimensionally proprotional to the output units of n. Since DimsMap factors out these proportions, one can simply check for equality between u_in and u_out of the two matrices. Thus for a matrix power, one simply has to:\n\nVerify that u_in is equal to u_out\nRaise the u_fac value by the desired power","category":"section"},{"location":"linearalgebra/#More-operations-coming","page":"Linear Algebra","title":"More operations coming","text":"Potential shortcut methods for DimsMap objects abound and can likely be applied to factorizations like eigendecomposition and cholesky factorization. Broadcasting operations are also likely targets to be short-cutted. To test if a shortcut method currently exists, simply perform it on LinmapQuant objects or VectorQuant objects. If a LinmapQuant or a VectorQuant object is returned, a shortcut method has been implemented. Otherwise a generic fallback has been used. This package also has semi-shortcut methods for combined operations between factorized LinmapQuant/VectorQuant objects and generic vectors and matrices of quantities. These methods tend to be O(N²), which is still better than the likely O(N³) alternative, but the advantage is that the resturn value should be factorized, optimizing long chains of linear algebra operations where possible.","category":"section"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/#Why-FlexUnits-is-fast","page":"Performance","title":"Why FlexUnits is fast","text":"FexUnits.jl combines techniques from Unitful.jl on \"static units\" to obtain near zero overhead performance when units can be resolved at parse time, but falls back to \"dynamic unit\" methods used by DynamicQuantities.jl if units cannot be inferred at parse time. This is done through promotion rules which convert static-dimension quantities to dynamic-dimension quantities if different dimensions are present. This retains the high-performance behaviour of Unitful.jl when units are known at compile time, but often falls back to the performance of DynanicQuantity.jl if they can't be inferred. In the first set of benchmarks, we see that FlexUnits.jl and DynamicQuantities.jl vastly outperform Unitful.jl (by more than 100x) when units cannot be inferred.\n\nusing FlexUnits\nusing .UnitRegistry\nimport DynamicQuantities\nimport Unitful\nusing BenchmarkTools\n\nv1uni  = [1.0*Unitful.u\"m/s\", 1.0*Unitful.u\"J/kg\", 1.0*Unitful.u\"A/V\"]\nv1dyn  = [1.0*DynamicQuantities.u\"m/s\", 1.0*DynamicQuantities.u\"J/kg\", 1.0*DynamicQuantities.u\"A/V\"]\nv1flex = [1.0u\"m/s\", 1.0u\"J/kg\", 1.0u\"A/V\"]\n\n@btime sum(x->x^0.0, $v1uni)\n  8.100 μs (86 allocations: 3.92 KiB)\n@btime sum(x->x^0.0, $v1dyn)\n  41.717 ns (0 allocations: 0 bytes)\n@btime sum(x->x^0.0, $v1flex)\n  5.300 ns (0 allocations: 0 bytes)\n\nIn the second example, we see that FlexUnits.jl and Unitful.jl outperform DynanicQuantities.jl when units can be inferred by the compiler.\n\nt1uni  = [1.0*Unitful.u\"m/s\", 1.0*Unitful.u\"m/s\", 1.0*Unitful.u\"m/s\"]\nt1dyn  = [1.0*DynamicQuantities.u\"m/s\", 1.0*DynamicQuantities.u\"m/s\", 1.0*DynamicQuantities.u\"m/s\"]\nt1flex = [1.0u\"m/s\", 1.0u\"m/s\", 1.0u\"m/s\"]\n\n@btime sum(x->x^2, $t1uni)\n  3.000 ns (0 allocations: 0 bytes)\n@btime sum(x->x^2, $t1dyn)\n  7.407 ns (0 allocations: 0 bytes)\n@btime sum(x->x^2, $t1flex)\n  3.000 ns (0 allocations: 0 bytes)\n\nWhile this performance boost over DynamicQuantities.jl isn't as dramatic as the previous boost over Unitful.jl, it is still significant. In most benchmarks (examples can be found in the test folder of the FlexUnits repo) FlexUnits matches the best performing alternative (DynamicQuantities or Unitful). There are two notable exceptions:\n\nFlexUnits.jl is slightly slower than Unitful.jl at uconvert, but still much faster than DynamicQuantities.jl\nFlexUnits.jl can be significantlhy faster than both Unitful.jl and DynamicQuantities.jl for iterative statically-inferred algorithms where unitful values are reassigned (Unitful tends to overspecialize but the FlexUnits design avoids this)","category":"section"},{"location":"performance/#Why-FlexUnits-is-efficient-at-linear-algebra","page":"Performance","title":"Why FlexUnits is efficient at linear algebra","text":"In order for matrix multiplication and other linear algebra operations to be possible, the units need to be consistent. In order to be consistent, the matrix must be constructed to take a vector with units u_in and produce a vector of units u_out. To do this, the units of an entire N×M matrix can be described by the following factorization\n\nA scalar dimension factor u_fact\nAn M-1 vector of input units u_in\nAn N-1 vector of output units u_out\n\nThis results in a matrix being described by N+M-1 values instead of NxM, this can result in a significant amount of compressions. Addiitonally, these factored units are stored separately from the matrix of numerical values. This factorization and separation provides the two main benefits:\n\nEfficient, well-tested, pure-numerical matrix operations can be performed on the raw numerical values\nUnit dimensions can be solved using efficient O(N) methods on DimsMap objects which only store (M+N+1) values instead of (M×N) values (DimsMap stores two more values than the bare-minimum for validation purposes).\n\nThese efficiency gains means that even if units must be dynamic (due to different units in the array), the overhead of resolving these units can be minimal. Let's compare mixed-unit matrix multiplication with differnt packages.","category":"section"},{"location":"performance/#Matrix-Multiplication-Benchmarks","page":"Performance","title":"Matrix Multiplication Benchmarks","text":"The first example consists of multiplying a 200x4 matrix by a 4x4 matrix\n\n#Use unitless matrices as a benchmark\nNr = 200\nX = randn(Nr, 4)\nM = rand(4,4)\n\n#Construct unitful matrices\nuu = [Unitful.u\"kg/s\", Unitful.u\"kW\", Unitful.u\"rad/s\", Unitful.u\"N/m\"]\nut = reshape(uu, 1, :)\nXu = X.*ut\nMu = inv.(uu) .* M .* inv.(ut)\n\n#Construct DynamicQuantity matrices\nudq = [DynamicQuantities.u\"kg/s\", DynamicQuantities.u\"kW\", DynamicQuantities.u\"rad/s\", DynamicQuantities.u\"N/m\"]\nudqt = reshape(udq, 1, :)\nXdq = X.*udqt\nMdq = inv.(udq) .* M .* inv.(udqt)\n\n#Construct LinmapQuant matrices\nufq = [UnitRegistry.u\"kg/s\", UnitRegistry.u\"kW\", UnitRegistry.u\"rad/s\", UnitRegistry.u\"N/m\"]\nXfq = LinmapQuant(X, UnitMap(u_out = UnitRegistry.u\"\", u_in = inv.(ufq)))\nMfq = LinmapQuant(M, UnitMap(u_out = inv.(ufq), u_in=ufq))\n\n\njulia> @btime X*M #No units\n  700.000 ns (3 allocations: 6.35 KiB)\n\njulia> @btime Xu*Mu #Unitful, more than 500x slower\n  395.700 μs (5603 allocations: 93.83 KiB)\n\njulia> @btime Xdq*Mdq #DynamicQuantities, about 8x slower\n  5.700 μs (3 allocations: 31.34 KiB)\n\njulia> @btime Xfq*Mfq #LinmapQuant, almsot no overhead\n  710.000 ns (4 allocations: 6.41 KiB)\n\nThe main reason why FlexUnits.jl has nearly no overhead is that only the inner product of the units between matrices is considered. Only the first 4-element row of X and the first column of M need to be compared. Unit inference does not touch the other 199 rows of X or the other 3 colums of M.","category":"section"},{"location":"performance/#Linear-Regression-Benchmarks","page":"Performance","title":"Linear Regression Benchmarks","text":"Linear regression benchmarks can only be compared between FlexUnits and the raw numerical methods. Neither Unitful.jl nor DynamicQuantities.jl can handle matrix inversions.\n\njulia> Mu/Mu #Unitful fails at 'oneunit'\nERROR: MethodError: no method matching oneunit(::Type{Any})\nThis error has been manually thrown, explicitly, so the method may exist but be intentionally marked as unimplemented.\n\njulia> Mdq/Mdq #DynamicQuantities also fails at 'oneunit'\nERROR: Cannot create a dimensionful 1 from `Type{DynamicQuantities.Quantity}` without knowing the dimensions. Please use `oneunit(::DynamicQuantities.Quantity)` instead.\n\njulia> collect(Mfq)/collect(Mfq) #Matrices of FlexUnit quantities fails further down becuase LU-factorization logic eventually compares quantities of different units\nERROR: DimensionError: (s²/kg², s⁴/(m² kg²)) have incompatible dimensions\n\njulia> Mfq/Mfq #FlexUnits LinmapQuant matrices actually work\n4×4 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n          1.0           0.0 m²/s²                 0.0 1/kg           -0.0 1/s\n     0.0 s²/m²               1.0   -3.29362e-21 s²/(m² kg)  -2.75549e-20 s/m²\n        0.0 kg     0.0 (m² kg)/s²                     1.0           -0.0 kg/s\n 6.32944e-16 s  -6.10423e-13 m²/s         2.87226e-16 s/kg               1.0\n\nWe can use linear algebra to complete the linear regression as follows:\n\nNr = 200\nXY = randn(Nr, 6) * rand(6, 6)\nX = [XY[:, begin:4] ones(Nr)]\nY = XY[:, 5:end]\nXu = LinmapQuant(X, UnitMap(u_out=UnitRegistry.u\"\", u_in=inv.([UnitRegistry.u\"kg/s\", UnitRegistry.u\"kW\", UnitRegistry.u\"rad/s\", UnitRegistry.u\"N/m\", UnitRegistry.u\"\"])))\nYu = LinmapQuant(Y, UnitMap(u_out=UnitRegistry.u\"\", u_in=inv.([UnitRegistry.u\"K\", UnitRegistry.u\"kPa\"])))\n\njulia> @btime (X'X)\\(X'Y) #No units\n  4.880 μs (12 allocations: 992 bytes)\n\njulia> @btime Bu = (Xu'Xu)\\(Xu'Yu) #LinmapQuant, about 1.3x slower\n  6.400 μs (19 allocations: 1.66 KiB)\n\nThis time, the overhead from unit inference was noticeable, but still much less than 2x. The reason for this is because Xu'*Xu is a long multiplication that compares the 200 columns of Xu' vs the 200 rows of Xu, with the same thing happening again in Xu'*Yu. Thankfully, this 200-row comparison is required only once for the 25 combinations of Xu'*Xu and once for the 10 combinations of Xu'*Yju. In general, unit inference is about 6x to 8x slower than floating-point operations, so having two unit inferences for every 35 floating-point operations gives a slowdown factor of (35+2*7)/35 = 1.4, almost exactly the slowdown that was seen in the benchmarks.","category":"section"},{"location":"performance/#Performance-Tips","page":"Performance","title":"Performance Tips","text":"While FlexUnits is generally fast, there are a few things one may need to watch out for to get the most out of this package.","category":"section"},{"location":"performance/#1.-Avoid-containers-with-mixed-static-unit-types,-use-dynamic-units-instead","page":"Performance","title":"1. Avoid containers with mixed static-unit types, use dynamic units instead","text":"A great deal of the work done in this package was devoted to building a performant type-stable dynamic unit/dimension system that can represent many different unit types and promotion rules that avoid mixed-type containers. While promotion rules help, some Julia functions don't apply conversion (this includes collect and map, but vcat(...) reliably promotes); if such mixed-type containers occur, use udynamic to explicitly convert static units to dynamic ones.","category":"section"},{"location":"performance/#2.-Use-dynamic-units-for-high-level-code","page":"Performance","title":"2. Use dynamic units for high-level code","text":"Dynanmic quantities are always type-stable and are less likely to result in accidental performance-killing dynamic dispatch calls. This is increasingly important if you want to produce small static binaries with Julia because dynamic dispatch can inhibit this. Using dynamic units can also prevent long compile times as it reduces specialization.","category":"section"},{"location":"performance/#3.-Use-LinmapQuant/VectorQuant-for-linear-algebra","page":"Performance","title":"3. Use LinmapQuant/VectorQuant for linear algebra","text":"These representations allow the use of optimized numerical methods for linear algebra, and employ shortcuts to solve the units of the matrix separately. This is especially important for large matrices. If input values are already numerical matrices, constructors for LinmapQuant are more efficient at attaching units to said vectors, as only N+M+1 dimension values are stored instead of the full M×N.","category":"section"},{"location":"performance/#4.-Pay-attention-to-the-output-types-of-linear-algebra-operations","page":"Performance","title":"4. Pay attention to the output types of linear algebra operations","text":"If a shortcut method is implemented, the output should be either a LinmapQuant or a VectorQuant. Otherwise a slower fallback method has been used. If this happens where not expected, please submit a bug report. It is likely that a method has been overlooked.","category":"section"},{"location":"performance/#5.-Use-dconvert-to-transition-from-dynamic-units-to-static-units-in-low-level-code","page":"Performance","title":"5. Use dconvert to transition from dynamic units to static units in low-level code","text":"Dynamic units are great for achieving effortless type stability, but static units really shine in performance-sensitive low-level code where there's a small number of variables with known dimensions. In such cases, one can simply use dconvert(u\"...\", q) to convert q to a quantity with the same dimensions as u. Because most of the calcualtion is done using dimensional quantities, no conversion math needs to take place, one simply needs to verify that the units match, thus dconvert has very little overhead.","category":"section"},{"location":"performance/#6.-Use-vcat-or-some-other-promoting-method-to-transition-from-low-level-code-to-high-level-code","page":"Performance","title":"6. Use vcat or some other promoting method to transition from low-level code to high-level code","text":"As mentioned before, some functions like collect and map don't use promote. However, other methods like explicit vector construction like v=[x,y,z] and using vcat on splatted tuples properly trigger promote. When returning containers with multiple units, make sure they are properly promoted to dynamic units, otherwise overspecialization and dynanmic calls may leak to other parts of your code.","category":"section"},{"location":"examples/#Advanced-Examples","page":"Advanced Examples","title":"Advanced Examples","text":"","category":"section"},{"location":"examples/#Solving-Differential-Equations","page":"Advanced Examples","title":"Solving Differential Equations","text":"It is currently possible to solve systems of differential equations using Unitful.jl, but it has some drawbacks:\n\nIt requires sectioning arrays with RecursiveArrayTools\nIt only works with explicit ODE solvers\nLinear algebra operations are less efficient\n\nWith FlexUnits, arrays with heterogeneous units are supported and linear algebra operations are efficient. Moreover, with a bit of extra work, it is now possible to use units with explict solvers like Rodas5P. Integration with DifferentialEquations.jl is still in its early stages, but so far, FlexUnits support for mixed-unit linear algebra has already proven to make itegration relatively easy.","category":"section"},{"location":"examples/#The-ODE-problem-(falling-object)","page":"Advanced Examples","title":"The ODE problem (falling object)","text":"This example will model a falling object with the drag force equation.\n\nusing FlexUnits, .UnitRegistry\nusing OrdinaryDiffEq\nusing StaticArrays\nusing Plots\nusing BenchmarkTools\nusing LinearAlgebra\n\n#Use named vectors for readability\n@kwdef struct FallingObjectState{T} <: FieldVector{2,T}\n    v  :: T\n    h  :: T\nend\n\n@kwdef struct FallingObjectProps{T} <: FieldVector{5,T}\n    Cd :: T\n    A  :: T\n    ρ  :: T\n    m  :: T\n    g  :: T\nend \n\n#Convert dynamic units to static units for performance\nfunction ustatic(state::FallingObjectState{<:Quantity})\n    return (\n        v = dconvert(u\"m/s\", state.v),\n        h = dconvert(u\"m\", state.h)\n    )\nend\n\nfunction ustatic(props::FallingObjectProps{<:Quantity})\n    return (\n        Cd = dconvert(u\"\", props.Cd),\n        A  = dconvert(u\"m^2\", props.A),\n        ρ  = dconvert(u\"kg/m^3\", props.ρ),\n        m  = dconvert(u\"kg\", props.m),\n        g  = dconvert(u\"m/s^2\", props.g)\n    )\nend\n\n#Main differntial equation (unit-agnostic)\nfunction acceleration_raw(u, p, t)\n    fd = -sign(u.v)*0.5*p.ρ*u.v^2*p.Cd*p.A\n    dv = fd/p.m - p.g\n    dh = u.v\n    return FallingObjectState(v=dv, h=dh)\nend\n\n#Main differential equation with a static unit wrapper (for performance)\nfunction acceleration_ustatic(u::AbstractVector{<:Quantity}, p::AbstractVector{<:Quantity}, t)\n    du = acceleration_raw(ustatic(FallingObjectState(u)), ustatic(FallingObjectProps(p)), t)\n    return FallingObjectState(du)\nend","category":"section"},{"location":"examples/#Solving-with-an-explict-solver-(Tsit5)","page":"Advanced Examples","title":"Solving with an explict solver (Tsit5)","text":"Solving this differential equation with an explicit solver like Tsit5 is relatively straightforward.\n\nu0 = FallingObjectState(v=0.0u\"m/s\", h=100u\"m\")\np  = FallingObjectProps(Cd=1.0u\"\", A=0.1u\"m^2\", ρ=1.0u\"kg/m^3\", m=50u\"kg\", g=9.81u\"m/s^2\")\n\ntspan = (0.0u\"s\", 10.0u\"s\")\nprob = ODEProblem{false, OrdinaryDiffEq.SciMLBase.NoSpecialize}(acceleration_ustatic, u0, tspan, p, abstol=[1e-6, 1e-6], reltol=[1e-6, 1e-6])\nsol = solve(prob, Tsit5())\nplt = plot(ustrip.(sol.t), [ustrip(u.v) for u in sol.u], label=\"Tsit5\")","category":"section"},{"location":"examples/#Solving-with-an-implicit-solver-(Rodas5P)","page":"Advanced Examples","title":"Solving with an implicit solver (Rodas5P)","text":"Unfortunately, implicit ODE solvers are a bit more complicated. The first major challenge is the fact that implicit solvers require differentiation. Automatic differentiation can differntiate through quantities, but it can't differentiate with respect to quantities. This means that the automatic differentiator needs to differentiate through the function without units, and the return a final Jacobian with units as shown in the wrapped_jacboan function definition below.\n\nusing ForwardDiff\nfunction wrapped_jacobian(f, x, p, t)\n    u_in  = dimension.(x)\n    u_out = dimension.(f(x,p,t))\n\n    function f_unitless(xn)\n        return dstrip.(f(xn.*u_in, p, t))\n    end\n    \n    return ForwardDiff.jacobian(f_unitless, dstrip.(x)) * DimsMap(u_in=u_in, u_out=u_out)\nend\n\nstatic_jac(u,p,t) = wrapped_jacobian(acceleration_ustatic, u, p, t)\n\nIn addition, we need to define some other parametrs to make Rodas5P work. The first is the tgrad parameter which differentiates the function with respect to time. Becuase this set of equations does not explicitly use time, the tgrad can simply be set to zero with units of dx/s, otherwise, we would neeed to use another wrapped gradient.\n\nstatic_tgrad(u,p,t) = [0.0u\"m/s^3\", 0.0u\"m/s^2\"]\n\nFinally, in order to properly make use of these customized gradient/Jacobian functions, we need to construct an ODEFunction object. In order to make it properly function however, we need to overwrite the default mass matrix\n\nmass_matrix = I*1ud\"\"\n\nThis is different from the default identy matrix I becasue it is unit-agnositc on the off-diagonals, where the default I assumes dimensionless values for all elements and causes unit validation failures when elements of v have different unit-dimensions. Using unit-agnostic elements ensures that mass_matrix*v always returns v regardless of its unit-dimensions. One can check this by verifying that off diagonals produce ?/?.\n\njulia> mass_matrix[1,2]\n0.0 ?/?\n\nWith this completed, we can now create an appropriate ODEFunction object and use the typical steps to solve.\n\nf_static = ODEFunction{false, OrdinaryDiffEq.SciMLBase.FullSpecialize}(acceleration_ustatic, \n    jac = static_jac, \n    tgrad = static_tgrad,\n    mass_matrix = mass_matrix\n)\n\nu0 = FallingObjectState(v=0.0u\"m/s\", h=100u\"m\")\np  = FallingObjectProps(Cd=1.0u\"\", A=0.1u\"m^2\", ρ=1.0u\"kg/m^3\", m=50u\"kg\", g=9.81u\"m/s^2\")\n\ntspan = (0.0u\"s\", 10.0u\"s\")\nprob = ODEProblem(f_static, u0, tspan, p, abstol=[1e-6, 1e-6], reltol=[1e-6, 1e-6])\n\nsol = solve(prob, Rodas5P())\nplt = plot!(plt, ustrip.(sol.t), [ustrip(u.v) for u in sol.u], label=\"Rodas5P\")\n\nWhile moving from Tsit5 to Rodas5P is significantly more effort with quantities than raw numbers, FlexUnits is the only package known to be capable of this functionality. Moreover, these steps, which are already baked into defaults for regular number, could be potentially baked into defaults through an extension on the future.","category":"section"},{"location":"examples/#Exact-conversions-with-Rational","page":"Advanced Examples","title":"Exact conversions with Rational","text":"This package defaults to using Float64 conversion factors to accomplish conversions. This often results in small but visually annoying roundoff errors.\n\nusing FlexUnits, .UnitRegistry\njulia> uconvert(u\"°C\", 32u\"°F\")\n5.684341886080802e-14 °C\n\njulia> uconvert(u\"°C\", 14u\"°F\")\n-9.999999999999943 °C\n\nHowever, FlexUnits is designed to be registry-agnostic, with simply registry construction so this default Float64 conversion behaviour doesn't have to be the case (which is why it isn't exported by default). A user can simply copy-paste the \"UnitRegistry.jl\" file and modify one line of code that assigns const UNITS to use the transform type AffineTransform{Rational{Int64}} instead of AffineTransform{Float64}. \n\nusing FlexUnits\n\nmodule RationalRegistry\n    #RegistryTools contains all you need to build a registry in one simple import\n    using ..RegistryTools\n\n    const UNIT_LOCK = ReentrantLock()\n    const UNITS = PermanentDict{Symbol, Units{Dimensions{FixRat32}, AffineTransform{Rational{Int64}}}}() #Just change the AffineTrnasform type\n\n    #Fill the UNITS registry with default values\n    registry_defaults!(UNITS)\n\n    #Ueses a ReentrantLock() on register_unit to prevent race conditions when multithreading\n    register_unit(p::Pair{String, <:Any}) = lock(UNIT_LOCK) do \n        register_unit!(UNITS, p)\n    end\n\n    #Parsing functions that don't require a dictionary argument\n    uparse(str::String) = RegistryTools.uparse(str, UNITS)\n    qparse(str::String) = RegistryTools.qparse(str, UNITS)\n\n    #String macros are possible now that we are internally referring to UNITS\n    macro u_str(str)\n        return esc(suparse_expr(str, UNITS))\n    end\n\n    macro ud_str(str)\n        return esc(uparse_expr(str, UNITS))\n    end\n\n    macro q_str(str)\n        return esc(qparse_expr(str, UNITS))\n    end\n    \n    #Functions to facilitate knowing types ahead of time, DO NOT EXPORT IF MULTIPLE REGISTRIES ARE USED\n    unittype() = RegistryTools.unittype(UNITS)\n    dimtype()  = RegistryTools.dimtype(UNITS)\n\n    #Registry is exported but these functions/macros are not (in case user wants their own verison)\n    #You can import these by invoking `using .Registry`\n    export @u_str, @ud_str, uparse, @q_str, qparse, register_unit\nend\n\nWe can then export all of the macros from our newly created RationalRegistry model, and check out the new behaviour.\n\nusing .RationalRegistry\n\njulia> uconvert(u\"°C\", 32u\"°F\")\n0//1 °C\n\njulia> uconvert(u\"°C\", 14u\"°F\")\n-10//1 °C\n\nThis can be used to modify many different behaviours if you don't agree with the design decisions of the default registry. FlexUnits registries are designed to be truly modular and flexible.","category":"section"},{"location":"manipulation/#Unit-Manipulation-and-Conversion","page":"Unit Manipulation","title":"Unit Manipulation and Conversion","text":"","category":"section"},{"location":"manipulation/#Retrieving-units-from-a-registry","page":"Unit Manipulation","title":"Retrieving units from a registry","text":"Unit registries are modules that export parsing functions and string macros. FlexUnits contains a default unit registry module named UnitRegistry that contains scalar/affine units. To use string macros, simply call the string macros and parsing functions from the registry.\n\nusing FlexUnits\ndistance1 = 1*UnitRegistry.u\"km\"\ndistance2 = 1*UnitRegistry.uparse(\"m\")\ndistance3 = 1*UnitRegistry.qparse(\"5 cm\")\n\njulia> distance1 + distance2 + distance3\n1001.05 m\n\nYou can export these functions and macros directly from the module (this is not done by default so that users can use their own custom modules if they like).\n\nusing FlexUnits, .UnitRegistry\ndistance1 = 1*u\"km\"\ndistance2 = 1*uparse(\"m\")\ndistance3 = 1*qparse(\"5 cm\")\n\njulia> distance1 + distance2 + distance3\n1001.05 m","category":"section"},{"location":"manipulation/#String-macro-and-parsing-behaviour","page":"Unit Manipulation","title":"String macro and parsing behaviour","text":"There are two types of string macros:\n\nOne that produces staticly-typed units @u_str such as 1u\"m/s\"\nOne that produces dynamic units @ud_str such as 1ud\"m/s\"\n\nMost of the time users will want to use the static unit macro inside code, because the Julia compiler can reason about the units with constants, resulting in better runtime because unit checking is all done at compile-time. One can check the types produced by these macros.\n\njulia> typeof(1u\"m/s\")\nQuantity{Float64, StaticDims{m/s}}\n\njulia> typeof(1ud\"m/s\")\nQuantity{Float64, Dimensions{FixRat32}}\n\nThere are also two types of parsing functions:\n\nOne that parses units uparse such as uparse(\"N\")\nOne that parses quantities qparse such as qparse(\"5 lbf\")\n\nParsing functions always produce dynamic units, as they are primarily used to parse free text as units (such as csv spreadsheets); in such cases, producing dynamic units resolves type-stability issues from not knowing the units beforehand. \n\nIt should also be notced that using string macros and parsing functions will cause units to be displayed exactly how they will be parsed (use quantity to prevent eagerly converting to dimensional units).\n\njulia> quantity(5, u\"J/(K*mol)\")\n5 J/(K*mol)\n\njulia> quantity(5, u\"J/(mol K)\")\n5 J/(mol K)\n\njulia> quantity(5, u\"J*(mol K)^(-1)\")\n5 J*(mol K)^(-1)\n\nDimensional units, however, are displayed in a standard format because their symbols are well-defined.\n\njulia> 5u\"J/(K*mol)\"\n5.0 (m² kg)/(s² K mol)\n\njulia> 5*u\"J*(mol K)^(-1)\"\n5.0 (m² kg)/(s² K mol)","category":"section"},{"location":"manipulation/#Registering-units","page":"Unit Manipulation","title":"Registering units","text":"You can register units to a registry using other units or quantities using the register_unit function:\n\njulia> register_unit(\"bbl\" => 0.158987*u\"m^3\")\n\nHowever, because macros only look up units at compile time, changing these values won't update macro outputs in functions that have already been compiled. Becuase of this, we use the PermanentDict object to produce errors when overwriting units with different values. You can re-register units with the same values (so that you can re-run scripts) but overwriting them as different values is not allowed.\n\njulia> register_unit(\"bbl\" => 0.158987*u\"m^3\")\nFlexUnits.RegistryTools.PermanentDict{Symbol, AffineUnits{Dimensions{FixedRational{Int32, 25200}}}} with 150 entries:\n\njulia> register_unit(\"bbl\" => 22.5*u\"m^3\")\nERROR: PermanentDictError: Key bbl already exists. Cannot assign a different value.","category":"section"},{"location":"manipulation/#Converting-units","page":"Unit Manipulation","title":"Converting units","text":"FlexUnits mimics Unitful where possible, so the uconvert function is used to convert quantities to desired units. However, internally, most math is done using dimensional quantities (i.e. SI units) so that no internal conversion factors are neccessary. Because dimensional quantities are higher-performacne, the dconvert function is also used, mainly to verify the dimensions of the input units and remove any scaling/offsets before calculation.","category":"section"},{"location":"manipulation/#Use-uconvert-for-displaying-results","page":"Unit Manipulation","title":"Use uconvert for displaying results","text":"The function uconvert is most often used for converting results of a calculation (usually SI) to the desired units.\n\nNote that using uconvert between two unit object will produce a unit conversion formula that can be called directly. Additionally, pipe operator |> can also be used as a shorthand for uconvert","category":"section"},{"location":"manipulation/#Use-dconvert-before-performance-sensitive-code","page":"Unit Manipulation","title":"Use dconvert before performance-sensitive code","text":"The funciton dconvert converts a quantity to the dimensions of the desired unit. This is a convenience function since string macros produce units, not dimensions. This may produce unintuitive results if you forget this behaviour, for example,\n\njulia> dconvert(u\"km/hr\", 25u\"km/hr\")\n6.944444444444445 m/s\n\nThis is useful for validating input unit dimensions and converting to a high-performance object all in one step before performing performance-sensitive code. In such cases, make sure you use the static version (i.e. use 5u\"m/s\" not 5ud\"m/s\").","category":"section"},{"location":"manipulation/#Extracting-units-and-values-from-quantities","page":"Unit Manipulation","title":"Extracting units and values from quantities","text":"The following functions can be used to extract/inspect different attributes of a quantity\n\nustrip(q::Quantity) extracts the raw numerical value from a quantity\nustrip(u::AbstractUnitLike, q::Quantity) returns the value of a quantity in the desired units\ndstrip(q::Quantity) converts a quantitty to dimensional units and returns the numerical value\nunit(q::Quantity) extracts the unit from a quantity (Quantity{Float64, <:AbstractDimLike} will return a dimension)\ndimension(q::Quantity) will return the dimensions of a quantity (if dimensions are static, it returns the static value)","category":"section"},{"location":"manipulation/#FlexUnits.uconvert-Tuple{AbstractUnitLike, QuantUnion}","page":"Unit Manipulation","title":"FlexUnits.uconvert","text":"uconvert(u::AbstractUnitLike, q::QuantUnion)\n\nConverts quantity q to the equivalent quantity having units u\n\njulia> uconvert(u\"K\", 25u\"°C\")\n298.15 K\n\n\n\n\n\n","category":"method"},{"location":"manipulation/#FlexUnits.uconvert-Tuple{AbstractUnitLike, AbstractUnitLike}","page":"Unit Manipulation","title":"FlexUnits.uconvert","text":"uconvert(u_target::AbstractUnitLike, u_current::AbstractUnitLike)\n\nProduces a conversion rule to convert u_current to u_target. This result is a callable object that can be applied directly to numeric objects.\n\njulia> uconvert(u\"K\", u\"°C\")\nAffineTransform{Float64}(1.0, 273.15)\n\njulia> uconvert(u\"K\", u\"°C\")(0)\n273.15\n\n\n\n\n\n","category":"method"},{"location":"manipulation/#Base.:|>-Tuple{AbstractUnitLike, Union{AbstractUnitLike, QuantUnion}}","page":"Unit Manipulation","title":"Base.:|>","text":"|>(x, f)\n\nInfix operator which applies function f to the argument x. This allows f(g(x)) to be written x |> g |> f. When used with anonymous functions, parentheses are typically required around the definition to get the intended chain.\n\nExamples\n\njulia> 4 |> inv\n0.25\n\njulia> [2, 3, 5] |> sum |> inv\n0.1\n\njulia> [0 1; 2 3] .|> (x -> x^2) |> sum\n14\n\n\n\n\n\n","category":"method"},{"location":"manipulation/#FlexUnits.dconvert-Tuple{AbstractUnitLike, QuantUnion}","page":"Unit Manipulation","title":"FlexUnits.dconvert","text":"dconvert(u::AbstractUnitLike, q::QuantUnion)\n\nConverts quantity q to the equivalent dimensional quantity having the same dimensions as u\n\njulia> dconvert(u\"km/hr\", 25u\"km/hr\")\n6.944444444444445 m/s\n\n\n\n\n\n","category":"method"},{"location":"#FlexUnits.jl","page":"Home","title":"FlexUnits.jl","text":"FlexUnits.jl is a unit package designed to resemble Unitful.jl, with similar performance when units can be statically inferred, but leverages techniques in DynamicQuantities.jl to eliminate many of Unitful's performance pitfalls when units are uninferrable. In addition, this package introduces special vector and matrix types that can infer output units for linear algebra operations at O(n) speeds, even if the numerical matrix operations are higher order (such as matrix inversions). When combining these techniques, this package allows the user to employ the following useful pattern:\n\nDefine high-level linear-algebra operations on quantities with dynamic units that are fast and type-stable even with mixed-unit types\nConvert quantities to statically-inferred high-performance units in lower-level performance-sensitive code","category":"section"},{"location":"#Quick-start-examples","page":"Home","title":"Quick start examples","text":"The FlexUnits API is designed to resemble Unitful in a number of ways. One major difference is that string macros and parsing functions are not exported by default, instead they are exported by a unit registry. This allows users to define their own registries and use those as a basis for unit parsing. FlexUnits provides a unit registry (UnitRegistry) that can be imported to provide default unit parsing functionality.\n\nadd FlexUnits\nusing FlexUnits, .UnitRegistry\n\nUnits are accessed primarily through string macros. The @u_str macro produces static units by default (for maximum performance when injected into low-level code), but if dynamic units are desired (particularly for interactive workflows) one can use the @ud_str macro. \n\njulia> 1u\"°C\"   #@u_str produces static units (multiplication converts to base units)\n274.15 K\n\njulia> 1ud\"°C\"  #@ud_str produces dynamic units (multiplication converts to base units)\n274.15 K\n\njulia> quantity(1, u\"°C\") #Use 'quantity' to avoid eager conversion to base units\n1 °C\n\nUnlike macros, units that need to be parsed from strings cannot be statically inferred, so the uparse function will always produce dynamic units in order to make it type-stable.\n\njulia> uparse(\"km/hr\")  #Uparse always produces dynamic units\nkm/hr\n\njulia> typeof(uparse(\"km/hr\")) == typeof(uparse(\"kPa\")) #Uparse is type-stable\ntrue\n\nThe function uconvert pays attention to the unit type converted to. If the unit is static, the resulting quantity will be static, if it's dynamic, the result will be dynamic.\n\njulia> typeof(uconvert(u\"°F\", 1u\"°C\")) #Converting to static units produces a static quantity\nQuantity{Float64, StaticUnits{K, AffineTransform}}\n\njulia> typeof(uconvert(ud\"°F\", 1u\"°C\")) #Converting to dynamic units produces a dynamic quantity\nQuantity{Float64, Units{Dimensions{FixRat32}, AffineTransform}}\n\njulia> 1u\"°C\" |> u\"°F\"  #The \"pipe\" operator is syntctic sugar for unit conversion\n33.799999999999955 °F\n\nThe function uconvert can also be used on two unit types. This produces an AbstractUnitTransform that when called on a number, applies the unit conversion conversion formula produced by the two units.\n\njulia> (u\"°C\" |> u\"°F\")(0)  #uconvert between two units produces a callable conversion formula\n31.999999999999943\n\nBecause operatins on dimensional quantities are more efficient than ones with units, FlexUnits also provides a dconvert function that will convert a quantity to the dimension of the units provided. This is particularly useful when converting dynanmic quantities to static-dimension quantities (the most peformant type).\n\njulia> q = dconvert(u\"mi/hr\", 1ud\"km/hr\")  #dconvert converts to dimensions of the target unit\n0.2777777777777778 m/s\n\njulia> typeof(q) #Using dconvert produces high-performance quantities (expecially with static units)\nQuantity{Float64, StaticDims{m/s}}\n\nMuch like Unitful, equivalence implies conversion (especially since there is a lot of eager conversion to dimensional quantities in this package).\n\njulia> 1u\"kg\" == 1000ud\"g\" #Equivalence implies conversion (even if using different static/dynamic modes)\ntrue\n\nFlexUnits parsing tends to be more flexible than other unit packages. For example, the empty string will parse to a unitless quantity. String macros also produce units whose symbol matches the input exactly. This information is erased however, if one tries to manipulate units directly. Because this packages converts to dimensional quantities for all mathematical operations, only dimensions need to be tracked, which is much more straightforward than tracking units.\n\njulia> 1u\"\"  #Empty string produces unitless value\n1.0\n\njulia> R = 8.314ud\"kJ/(mol K)\"  #String macros produce the unit's symbols exactly\n8.314 kJ/(mol K)\n\njulia> R = 8.314ud\"kJ/(K*mol)\"  #This displays a different result\n8.314 kJ/(K*mol)\n\njulia> u\"kJ\"/(u\"K\"*u\"mol\")  #Math operations on units delete symbol information (don't do this)\nUnits{Dimensions{FixRat32}, AffineTransform}((m² kg)/(s² K mol), AffineTransform(1000.0, 0.0), :_)\n\nPromotion rules will convert static dimensional quantities to dynamic ones if the dimensions are different\n\njulia> [1u\"m/s\", 2u\"m/s\", 3u\"km/hr\"]  #Same static dimensions produces an array with static units\n3-element Vector{Quantity{Float64, StaticDims{m/s}}}:\n 1.0 m/s\n 2.0 m/s\n 0.8333333333333334 m/s\n\njulia> [1u\"m/s\", 2u\"m/s\", 3u\"lb/s\"]   #Different static dimensions promote to a dynamic dimension\n3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:\n 1.0 m/s\n 2.0 m/s\n 1.360776 kg/s\n\njulia> [1ud\"m/s\", 2ud\"m/s\", 3ud\"lb/s\"]  #Mathematical operations tend to convert to SI units for performance\n3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:\n 1.0 m/s\n 2.0 m/s\n 1.360776 kg/s","category":"section"},{"location":"#Registering-units","page":"Home","title":"Registering units","text":"You can register units to UnitRegistry (or your own registry) using the register_unit function. You can simply provide it a single pair argument of type Pair{String, AbstractUnitLike} or Pair{String, Quantity} as follows: \n\njulia> register_unit(\"bbl\" => 0.158987*u\"m^3\")\nFlexUnits.RegistryTools.PermanentDict{Symbol, AffineUnits{Dimensions{FixedRational{Int32, 25200}}}} with 150 entries:\n  :Ω      => Ω\n  :μs     => μs\n  :μV     => μV\n\nHowever, due to the nature of macros, these dictionaries are permanent. You can re-register units with the same values (so that you can re-run scripts) but changing them is not allowed.\n\njulia> register_unit(\"bbl\" => 0.158987*u\"m^3\")\nFlexUnits.RegistryTools.PermanentDict{Symbol, AffineUnits{Dimensions{FixedRational{Int32, 25200}}}} with 150 entries:\n  :Ω      => Ω\n  :μs     => μs\n  :μV     => μV\n\njulia> register_unit(\"bbl\" => 22.5*u\"m^3\")\nERROR: PermanentDictError: Key bbl already exists. Cannot assign a different value.\n\nIt is possible for users to create their own registries (for example, if they wanted different dimension types or different classes of units). The default UnitRegistry (see the UnitRegistry.jl file in the source code) was constructed with less than 50 lines of code, and users can use that as a template. Most custom registries only need to modify two of these lines of code:\n\nconst UNITS = PermanentDict{Symbol, Units{Dimensions{FixRat32}, AffineTransform}}()\n\n#Fill the UNITS registry with default values\nregistry_defaults!(UNITS)\n\nThe UNITS constant is the dictionary where all the units live. One can customize it so that the registry has a different dimension type or even a different transform type. The registry_defaults! function fills a dictionary with the default body of units (users can build their own if they like).","category":"section"},{"location":"#Linear-Algebra","page":"Home","title":"Linear Algebra","text":"This package devines a LinmapQuant, a matrix that is intended to be a linear mapping that takes a vector with units u_in and produces a vector with units u_out thus, the dimensiosn of all elements can be inferred by these two vectors of units. While in general, the units of matrix elements can be arbitrary, in order to support operations like matrix multiplication, the units must adhere to this structure, and the simplicity of this structure allows for shortcuts for inference.\n\nIf we want to construct a matrix where all of the columns have the same units, we let u_in be the inverse of the units we desire, and u_out be dimensionless.\n\njulia> Z = randn(200, 5)*randn(5,5)\njulia> Zu = LinmapQuant(Z, UnitMap(u_in=inv.([u\"lb\", u\"ft\", u\"W\", u\"L\", u\"mol\"]), u_out=u\"\"))\n200×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n  -0.501901 kg    0.137162 m  -0.689416 (m² kg)/s³   -0.00173674 m³    4.09169 mol\n    1.84433 kg    0.335457 m   0.987017 (m² kg)/s³   -0.00204628 m³    3.95951 mol\n  -0.470226 kg   0.0676007 m   -2.44338 (m² kg)/s³     0.0013448 m³   -2.37904 mol\n  -0.373749 kg    0.157584 m   -2.97929 (m² kg)/s³    0.00555965 m³   -2.68827 mol\n\nWe could have also built the quantity matrix first and then used LinmapQuant(m::AbstractMatrix{<:Quantity}). Now let us suppose we wanted to do linear regression to predict the last two columsn given the first three.\n\njulia> Xu = [Zu[:,1:3] fill(1.0u\"\", size(Zu,1))]\n200×4 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n  -0.501901 kg    0.137162 m  -0.689416 (m² kg)/s³  1.0\n    1.84433 kg    0.335457 m   0.987017 (m² kg)/s³  1.0\n  -0.470226 kg   0.0676007 m   -2.44338 (m² kg)/s³  1.0\n  -0.373749 kg    0.157584 m   -2.97929 (m² kg)/s³  1.0 \n\njulia> Yu = Zu[:,4:5]\n200×2 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n  -0.00173674 m³    4.09169 mol\n  -0.00204628 m³    3.95951 mol\n    0.0013448 m³   -2.37904 mol\n   0.00555965 m³   -2.68827 mol\n\njulia> Bu = (Xu'*Xu)\\(Xu'*Yu)\n4×2 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n     -0.000206539 m³/kg          -0.109595 mol/kg\n          -0.0032453 m²             2.41413 mol/m\n -0.000997411 (m s³)/kg  0.75641 (s³ mol)/(m² kg)\n        -0.000152683 m³              0.159627 mol  \n\nWe can verify that the output of the prediction matches Yu\n\njulia> Xu*Bu\n200×2 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:\n  0.000193479 m³  0.0242788 mol\n  -0.00260673 m³    1.51392 mol\n    0.0021621 m³   -1.47384 mol\n   0.00238468 m³   -1.67255 mol\n    -0.001745 m³   0.810835 mol","category":"section"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Quantities","page":"Types","title":"Quantities","text":"FlexUnits.jl has two types of quantity values. FlexQuant, which can contain any object as a value, and Quantity which subtypes to Number (following the convention of most of Julia's unit packages). For convenience, they are often referred to together as QuantUnion. Mathematical operations on a QuantUnion with a Unit will convert to a dimensional quantity (SI by default) having an AbstractDimension instead of a AbstractUnit.","category":"section"},{"location":"types/#Dimensions","page":"Types","title":"Dimensions","text":"Dimensions are the core object used to define units, and Quantity values tend to have some form of AbstractDimension in its unit field after calculations due to computational simplicity. ","category":"section"},{"location":"types/#Units","page":"Types","title":"Units","text":"Units contain an AbstractDimensions and an AbstractUnitTransform which represents a conversion formula to convert the Quantity to its pure dimensional form. Typically, the unit transform is called before a calcualtion to convert the quantity to dimensional form, and uconvert applies an invers of that transform to convert the result back to the desired unit. Because dimensions have no transforms, it is most efficient to perform calculations directly on dimensional quantities.","category":"section"},{"location":"types/#Unit-Transforms","page":"Types","title":"Unit Transforms","text":"One unique feature to the FlexUnits design is the AbstractUnitTransform object. This is a callable object that contains a conversion formula to convert the unit into its dimensional form. The default transforms are NoTransform (a property of all dimensions) and AffineTransform which can deal with all common linear units. This design could potentially support other transforms like LogTransform for logarithmic units likd dB and pH in the future.","category":"section"},{"location":"types/#Linear-Algebra","page":"Types","title":"Linear Algebra","text":"Linear algebra functionality is achieved by observing that any matrix of quantities that supports multiplication is a special kind of quantity matrix that functions as a linear mapping. Such matrices have a special structure for units. These special unit structures are unit mappings that contain an input vector of units, and an output vector of units. Accellerated linear algebra operations are achived by keeping numerical matrices and unit mappings separate in a LinmapQuant and performing the linear algebra and unit inference separately (not unlike how a Quantity operates).","category":"section"},{"location":"types/#Unit-Maps","page":"Types","title":"Unit Maps","text":"","category":"section"},{"location":"types/#Objects-with-Unit-Maps","page":"Types","title":"Objects with Unit Maps","text":"","category":"section"},{"location":"types/#FlexUnits.Quantity","page":"Types","title":"FlexUnits.Quantity","text":"struct Quantity{T<:Number, U<:AbstractUnitLike} <: Number\n    value :: T\n    unit  :: U\nend\n\nNumeric quantity type (that sutypes to number) with fields value and unit\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.FlexQuant","page":"Types","title":"FlexUnits.FlexQuant","text":"struct FlexQuant{T<:Any, U<:AbstractUnitLike}\n    value :: T\n    unit  :: U\nend\n\nGeneric quantity type (that can hold any value) with fields value and unit\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.QuantUnion","page":"Types","title":"FlexUnits.QuantUnion","text":"QuantUnion{T<:Any,U<:AbstractUnitLike}\n\nConvenience union that allows Number and Non-Number types to be considered together\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.AbstractDimensions","page":"Types","title":"FlexUnits.AbstractDimensions","text":"AbstractDimensions\n\nA class that represents a specific dimensional schema, by default, its only child is Dimensions (SI units), but users can build their own versions  (even based on imperial measurements, or where angles are a dimension)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.Dimensions","page":"Types","title":"FlexUnits.Dimensions","text":"Dimensions{P}\n\nBasic SI dimensions:     length = m,      mass = kg,      time = s,      current = A,      temperature = K,      luminosity = cd,      amount = mol\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.StaticDims","page":"Types","title":"FlexUnits.StaticDims","text":"StaticDims{D} <: AbstractDimLike\n\nStatic dimensions where the D` is the dimension value. This improves performance when dimensions are statically inferrable.\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.AbstractUnits","page":"Types","title":"FlexUnits.AbstractUnits","text":"AbstractUnits\n\nAll units in FlexDims contain two entities:  (1) AbstractDimLike (anything that can be interpreted as a dimension) (2) AbstractTransform (contains the formula to convert unit value to dimensions)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.Units","page":"Types","title":"FlexUnits.Units","text":"@kwdef struct Units{D<:AbstractDimensions, T<:AbstractUnitTransform} <: AbstractUnits{D, T}\n    dims   :: D\n    todims :: T\n    symbol :: Symbol = DEFAULT_USYMBOL\nend\n\nA dynamic unit object that contains dimensions (dims) and its conversion formula to said dimensions (todims). The conversion  formula determines what kind of unit is referred to. An AffineTransform implies affine units, a NoTransform implies dimensions. Dynamic units can generated through the @ud_str macro.\n\nConstructors\n\nUnits{D}(units, todims::T, symbol=DEFAULT_USYMBOL) where {D,T<:AbstractUnitTransform} \nUnits(dims::D, todims::AbstractUnitTransform=NoTransform(), symbol=DEFAULT_USYMBOL) where D<:AbstractDimensions \nUnits(units::D, todims::AbstractUnitTransform, symbol=DEFAULT_USYMBOL) where D<:AbstractUnits\n\njulia> 1*(5ud\"°C\") #Operations on units eagerly convert to dimensions\n278.15 K\n\njulia> 1*(5du\"°C\") |> ud\"°C\" #Converts operation results back to Celsius\n5.0 °C\n\njulia> (5ud\"°C\" + 2ud\"°C\") |> ud\"°C\" #Operation adds values in Kelvin, results converted back to Celsius\n280.15 °C\n\njulia> (ustrip(5ud\"°C\") + ustrip(2ud\"°C\"))*u\"°C\" #Strips, adds raw quantity values, converts raw number to Celsius\n7 °C\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.StaticUnits","page":"Types","title":"FlexUnits.StaticUnits","text":"@kwdef struct StaticUnits{D, T<:AbstractUnitTransform} <: AbstractUnits{D,T}\n    todims :: T\n    symbol :: Symbol\nend\n\nA static version of units, where the value of dimensions D is a a parameter. Static units can generated through the @u_str macro. This improves performance when dimensions are statically inferrable.\n\nConstructors\n\nStaticUnits(u::Units) = StaticUnits{dimension(u)}(todims(u), usymbol(u))\nStaticUnits(d::AbstractDimensions, todims::AbstractUnitTransform, symb=DEFAULT_USYMBOL) = StaticUnits{d}(todims, symb)\nStaticUnits(d::StaticDims{D}, todims::AbstractUnitTransform, symb=DEFAULT_USYMBOL) where D = StaticUnits{D}(todims, symb)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.AbstractUnitTransform","page":"Types","title":"FlexUnits.AbstractUnitTransform","text":"AbstractUnitTransform\n\nAn abstract object representing a unit conversion formula.  Any object that subtypes this is made callable.\n\n# Callable form \nutrans = uconvert(u\"°C\", u\"°F\")\nutrans(0.0)\n31.999999999999986\n\n# Shorthand callable form (syntactic sugar)\n(u\"°C\" |> u\"°F\")(0.0)\n31.999999999999986\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.NoTransform","page":"Types","title":"FlexUnits.NoTransform","text":"NoTransform object, the default transform returned by todims(x::AbstractDimensionLike). Calling it results in  an identity.\n\nt = NoTransform()\nt(\"anything\")\n\"anything\"\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.AffineTransform","page":"Types","title":"FlexUnits.AffineTransform","text":"@kwdef struct AffineTransform{T<:Real} <: AbstractUnitTransform\n    scale  :: T = 1.0\n    offset :: T = 0.0\nend\n\nA type representing an affine transfomration formula that can be used to convert values from one affine unit to another. This object is callable.\n\nConstructors\n\nAffineTransform(scale::Real, offset::Real)\nAffineTransform(; scale, offset)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.UnitMap","page":"Types","title":"FlexUnits.UnitMap","text":"struct UnitMap{U<:UnitOrDims, TI<:ScalarOrVec{U}, TO<:ScalarOrVec{U}} <: AbstractUnitMap{U}\n    u_in  :: TI\n    u_out :: TO\nend\n\nUsed to represent a unit transformation from input units 'uin' to outpout units 'uout'. Often applied to nonlinear functions.\n\nConstructors\n\nUnitMap{U}(u_in::ScalarOrVec{<:AbstractUnitLike}, u_out::ScalarOrVec{<:AbstractUnitLike}) where U<:AbstractUnitLike\nUnitMap(u_in::ScalarOrVec{U1}, u_out::ScalarOrVec{U2}) where {U1<:AbstractUnitLike, U2<:AbstractUnitLike}\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.DimsMap","page":"Types","title":"FlexUnits.DimsMap","text":"struct DimsMap{D<:AbstractDimLike, TI<:AbstractVector{D}, TO<:AbstractVector{D}} <: AbstractDimsMap{D}\n    u_fac :: D\n    u_in  :: TI\n    u_out :: TO\nend\n\nUsed to represent a unit transformation from input dimensions 'uin' to outpout dimensions 'uout'. This is like a unit map but focuses on dimensions and has matrix-like behaviour since dimensions  support linear algebra, but generic units may not (affine units, logarithmic units etc).\n\nWARNING: The DimsMap constructor on dimensions expects uin and uout to be scaled so that the first  element is dimensionless. To prevent excessive allocations, uin and uout may be mutated in-place.  If mutating arguments is undesirable, supply immutable arguments or copies; otherwise, ensure  that uin and uout have dimensionless values in their first element.\n\nConstructors\n\nDimsMap(u_fac::U, u_in::TI, u_out::TO) where {U<:AbstractUnitLike, TI<:AbstractVector{<:AbstractUnitLike}, TO<:AbstractVector{<:AbstractUnitLike}}\nDimsMap(u_fac::Nothing, u_in::TI, u_out::TO) where {TI<:AbstractVector{<:AbstractUnitLike}, TO<:AbstractVector{<:AbstractUnitLike}}\nDimsMap(md::AbstractMatrix{<:AbstractDimLike})\nDimsMap(mq::AbstractMatrix{<:QuantUnion})\nDimsMap(d::AbstractDimsMap)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.LinmapQuant","page":"Types","title":"FlexUnits.LinmapQuant","text":"struct LinmapQuant{T, D<:AbstractDimensions, M<:AbstractMatrix{T}, U<:UnitMaps{D}} <: AbstractMatrix{Quantity{T,D}}\n    values :: M\n    units :: U\nend\n\nA linear mapping of quantities. A special kind of matrix that is intended to be used for multiplying vectors of quantities; such matrices must be dimensionally consistent and can be represented by a UnitMap. These constraints lead to much faster  unit inference and a smaller memory footprint (O(M+N) instead of O(MNN2) in the case of multiplication).\n\nConstructors\n\nLinmapQuant(m::AbstractMatrix{T}, u::UnitMap) where T\nLinmapQuant(m::SMatrix{Nr,Nc,T}, u::UnitMap) where {T, Nr, Nc}\nLinmapQuant(m::QuantArrayVals, d::QuantArrayDims)\nLinmapQuant(m::AbstractMatrix)\nLinmapQuant(m::LinmapQuant)\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.FunctionQuant","page":"Types","title":"FlexUnits.FunctionQuant","text":"struct FunctionQuant{F, U<:AbstractUnitMap}\n    func  :: F\n    units :: U\nend\n\nA generic mapping with units. Useful for applying units to unitless functions that assume units for inputs/outputs.\n\n\n\n\n\n","category":"type"},{"location":"types/#FlexUnits.FactorQuant","page":"Types","title":"FlexUnits.FactorQuant","text":"struct FactorQuant{T, D<:AbstractDimensions, F<:Factorization{T}, U<:AbstractUnitMap{D}}\n    factor :: F\n    dims  :: U \nend\n\nA factored linear mapping. A subclass of Factorizations with a unit mapping attached. Calling getproperty is re-routed to the original factor, with the appropriate units calcualted from the mapping.\n\n\n\n\n\n","category":"type"}]
}
