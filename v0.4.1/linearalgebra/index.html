<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Algebra · FlexUnits.jl</title><meta name="title" content="Linear Algebra · FlexUnits.jl"/><meta property="og:title" content="Linear Algebra · FlexUnits.jl"/><meta property="twitter:title" content="Linear Algebra · FlexUnits.jl"/><meta name="description" content="Documentation for FlexUnits.jl."/><meta property="og:description" content="Documentation for FlexUnits.jl."/><meta property="twitter:description" content="Documentation for FlexUnits.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FlexUnits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../performance/">Performance</a></li><li><a class="tocitem" href="../manipulation/">Unit Manipulation</a></li><li class="is-active"><a class="tocitem" href>Linear Algebra</a><ul class="internal"><li><a class="tocitem" href="#Unknown-Dimensions"><span>Unknown Dimensions</span></a></li><li><a class="tocitem" href="#Unit-Factorization"><span>Unit Factorization</span></a></li><li><a class="tocitem" href="#Factored-Unit-Shortcuts"><span>Factored Unit Shortcuts</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Advanced Examples</a></li><li><a class="tocitem" href="../types/">Types</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Linear Algebra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Algebra</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Deduction42/FlexUnits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Deduction42/FlexUnits.jl/blob/main/docs/src/linearalgebra.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Algebra"><a class="docs-heading-anchor" href="#Linear-Algebra">Linear Algebra</a><a id="Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra" title="Permalink"></a></h1><p>FlexUnits provides broader support for mixed-unit operations than other packages to date. This is done in to major ways:</p><ol><li>Using a sentinel value to denote unknown dimensions and yield a one-time bypass to unit checking</li><li>Factoring units with LinmapQuant object to separate matrices from units, and provide shortcut methods to infer units on various operations</li></ol><h2 id="Unknown-Dimensions"><a class="docs-heading-anchor" href="#Unknown-Dimensions">Unknown Dimensions</a><a id="Unknown-Dimensions-1"></a><a class="docs-heading-anchor-permalink" href="#Unknown-Dimensions" title="Permalink"></a></h2><h3 id="Much-of-Julia-codebase-breaks-when-dimensions-are-unknown"><a class="docs-heading-anchor" href="#Much-of-Julia-codebase-breaks-when-dimensions-are-unknown">Much of Julia codebase breaks when dimensions are unknown</a><a id="Much-of-Julia-codebase-breaks-when-dimensions-are-unknown-1"></a><a class="docs-heading-anchor-permalink" href="#Much-of-Julia-codebase-breaks-when-dimensions-are-unknown" title="Permalink"></a></h3><p>Much of the core Julia ecosystem relies the pattern of initializing values with <code>zero(T::Number)</code>, initializing matrices with <code>zeros</code> or even accessing <code>zero</code> elements in a sparse array. This works when the dimensions are statically known, but fails when they are not.</p><pre><code class="language-julia hljs">julia&gt; Diagonal(randn(3).*Unitful.u&quot;m/s&quot;)[1,2] #Unitful.jl works when units are statically known
0.0 m s^-1

julia&gt; Diagonal(randn(3).*[Unitful.u&quot;m/s&quot;, Unitful.u&quot;kg/hr&quot;, Unitful.u&quot;kW&quot;])[1,2] #Unitful.jl fails when units are not statically known
ERROR: ArgumentError: zero(Unitful.Quantity{Float64}) not defined.

julia&gt; Diagonal(randn(3).*DynamicQuantities.u&quot;m/s&quot;)[1,2] #DynamicQuantities works because it factors this out as a QuantityArray
0.0 m s⁻¹

julia&gt; Diagonal(randn(3).*[DynamicQuantities.u&quot;m/s&quot;, DynamicQuantities.u&quot;kg/hr&quot;, DynamicQuantities.u&quot;kW&quot;]) #DynamicQuantities won&#39;t let you build a Diagonal matrix with different dimensions
ERROR: DimensionError: -0.18627823028424698 m s⁻¹ and DynamicQuantities.Quantity{Float64, DynamicQuantities.Dimensions{DynamicQuantities.FRInt32}}[-0.18627823028424698 m s⁻¹, -0.00021716734256511895 kg s⁻¹, -262.81003984968476 m² kg s⁻³] have incompatible dimensions

julia&gt; sparse([1,2,3], [1,2,3], [DynamicQuantities.u&quot;m/s&quot;, DynamicQuantities.u&quot;kg/hr&quot;, DynamicQuantities.u&quot;kW&quot;])[1,2] #Sparse results in same problem as Unitful
ERROR: Cannot create an additive identity from `Type{&lt;:DynamicQuantities.Quantity}`, as the dimensions are unknown. Please use `zero(::DynamicQuantities.Quantity)` instead.</code></pre><h3 id="FlexUnits-provides-an-unknown-dimension"><a class="docs-heading-anchor" href="#FlexUnits-provides-an-unknown-dimension">FlexUnits provides an unknown dimension</a><a id="FlexUnits-provides-an-unknown-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#FlexUnits-provides-an-unknown-dimension" title="Permalink"></a></h3><p>FlexUnits works like Unitful when units are statically known, but when they are not, a sentinel value is used to denote unknown dimensions. This is done by setting every dimension element to its <code>typemax</code> value (which is a very improbable value of <code>2147483647//25200</code> for the default <code>FixRat32</code> type). Unknown dimensions are displayed as <code>?/?</code></p><pre><code class="language-julia hljs">julia&gt; Diagonal(randn(3).*u&quot;m/s&quot;)[1,2] #FlexUnits correctly returns unitful result when units are statically known
0.0 m/s

julia&gt; Diagonal(randn(3).*[u&quot;m/s&quot;, u&quot;kg/hr&quot;, u&quot;kW&quot;])[1,2] #FlexUnits returns an object with unknown dimensions 
0.0 ?/?

julia&gt; Diagonal(randn(3).*[u&quot;m/s&quot;, u&quot;kg/hr&quot;, u&quot;kW&quot;])[1,2] + 5u&quot;m/s&quot; #Unit-validating operations like &#39;+&#39; bypass unit validation once
5.0 m/s</code></pre><p>This solves the &quot;additive identity&quot; problem mentioned in the DynamicQuantities error. In general, operations that change dimensions (like multiplication, division, and exponentiation) propagate the unknown dimension flag value, while operations that validate units (addition, subtraction, max/min) will return a known dimension.</p><pre><code class="language-julia hljs">julia&gt; zero(Quantity{Float64, Dimensions{FixRat32}}) #zero produces unknown units when fed a type
0.0 ?/?

julia&gt; zero(Quantity{Float64, Units{Dimensions{FixRat32},AffineTransform{Float64}}}) #zero only works on dimensional quantities
ERROR: ArgumentError: This operation only supports dimensional quantities

julia&gt; oneunit(Quantity{Float64, Dimensions{FixRat32}}) * 5u&quot;kW&quot; #Unknown dimensions propagate through multiplication, values are scaled to SI
5000.0 ?/?

julia&gt; max(500*oneunit(Quantity{Float64, Dimensions{FixRat32}}), 2u&quot;J&quot;) #Comparison is done on the SI scale and returns known units
500.0 (m² kg)/s²</code></pre><h3 id="Mitigating-risks-of-silently-wrong-results"><a class="docs-heading-anchor" href="#Mitigating-risks-of-silently-wrong-results">Mitigating risks of silently wrong results</a><a id="Mitigating-risks-of-silently-wrong-results-1"></a><a class="docs-heading-anchor-permalink" href="#Mitigating-risks-of-silently-wrong-results" title="Permalink"></a></h3><p>One potential issue for unkown dimensions is the ability to silently retrun the wrong results. The main way this is mitigated is to only support unknown values on raw dimensions. Since all dimensional units (like SI) can be converted to each other without any scaling factors, the scale numerical results will always be consistent. The only kind of error that can happen is a wrongly bypassed dimensional validation. Since validation can only be bypassed once, initializers (which predate validation) are not going to be an issue.</p><pre><code class="nohighlight hljs">julia&gt; zero(Quantity{Float64, Dimensions{FixRat32}}) + 3u&quot;km/hr&quot; #This makes sense, initializer is ignorant
0.8333333333333334 m/s

julia&gt; zero(Quantity{Float64, Dimensions{FixRat32}}) + 3u&quot;km/hr&quot; + 2u&quot;kg&quot; #Incorrect operations still get flagged
ERROR: DimensionError: (m/s, kg) have incompatible dimensions

julia&gt; julia&gt; Diagonal([1u&quot;m/s&quot;, 1u&quot;kg&quot;, 1u&quot;mol&quot;])*(ones(3).*u&quot;s&quot;) #Matrix multiplication naturally works
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
       1.0 m
  1.0 (kg s)
 1.0 (s mol)</code></pre><p>The main risk is therefor accidentally deleting known unit information. As seen in the eample above, this doesn&#39;t happen as long as the units are full-rank. Issues can still happen with very sparse matrices through, and results clearly show that unknown dimensions are present.</p><pre><code class="language-julia hljs">julia&gt; sparse([1,3], [1,3], [1u&quot;m/s&quot;, 1u&quot;mol&quot;])*(ones(3).*u&quot;s&quot;)
3-element Vector{Quantity{Float64, Dimensions{FixRat32}}}:
       1.0 m
     0.0 ?/?
 1.0 (s mol)</code></pre><p>When matrices are this sparse, unkown dimensions in the result are understandable. However if the position in the matrix can be associated with a dimension, this problem can be solved by wrapping the numerical sparse matrix inside a LinmapQuant (explained in the next subsection). </p><p>The other risk from unknown dimensions is confusion between <code>one</code> and <code>oneunit</code></p><pre><code class="language-julia hljs">julia&gt; one(Quantity{Float64, Dimensions{FixRat32}}) * 2u&quot;A&quot; #Calling &#39;one&#39; maintains unit information
2.0 A

julia&gt; oneunit(Quantity{Float64, Dimensions{FixRat32}}) * 2u&quot;A&quot; #Calling &#39;oneunit&#39; deletes unit information
2.0 ?/?</code></pre><p>Careful understanding of the nuances between these two functions should be acquired before attempting to use these functions. Even with this potential for confusion, when testing against common Julia functions and patterns, introducing unkown dimensions solves far more problems than it creates.</p><h2 id="Unit-Factorization"><a class="docs-heading-anchor" href="#Unit-Factorization">Unit Factorization</a><a id="Unit-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Factorization" title="Permalink"></a></h2><h3 id="DimsMap-factorization-compresses-the-units-as-a-mapping"><a class="docs-heading-anchor" href="#DimsMap-factorization-compresses-the-units-as-a-mapping">DimsMap factorization compresses the units as a mapping</a><a id="DimsMap-factorization-compresses-the-units-as-a-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#DimsMap-factorization-compresses-the-units-as-a-mapping" title="Permalink"></a></h3><p>In order for matrix multiplication and other linear algebra operations to be possible, the units need to be consistent. In order to be consistent, the matrix must be constructed to take a vector with units <code>u_in</code> and produce a vector of units <code>u_out</code>. To do this, the units of an entire N×M matrix can be described by the following factorization as a <code>DimsMap</code></p><ul><li>A scalar dimension factor <code>u_fac</code></li><li>An M-1 vector of input units <code>u_in</code></li><li>An N-1 vector of output units <code>u_out</code></li></ul><p>The internal object <code>DimsMap</code> represents this factorization into base units (although it uses N and M vectors and forces the first element to be dimensionless).</p><h3 id="LinmapQuant-separates-unit-factorization-from-the-numbers"><a class="docs-heading-anchor" href="#LinmapQuant-separates-unit-factorization-from-the-numbers">LinmapQuant separates unit factorization from the numbers</a><a id="LinmapQuant-separates-unit-factorization-from-the-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#LinmapQuant-separates-unit-factorization-from-the-numbers" title="Permalink"></a></h3><p>The <code>LinmapQuant</code> object separates a numerical matrix from a <code>DimsMap</code>. For vectors, the <code>VectorQuant</code> object simply has a vector of numbers and a vector of base units. This separation provides the following benefits:</p><ol><li>Efficient, well-tested, pure-numerical matrix operations can be performed on the raw numerical values</li><li>Unit dimensions can be solved using efficient O(N) methods on DimsMap objects which only store (M+N+1) values instead of (M×N) values</li></ol><p>Thus, in order to perform a matrix operation, one simply performs the operations on the pure numerical values, and then perform the accelerated counterpart operation on the <code>DimsMap</code>.</p><h3 id="Constructor-Examples"><a class="docs-heading-anchor" href="#Constructor-Examples">Constructor Examples</a><a id="Constructor-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-Examples" title="Permalink"></a></h3><p>The easiest way to construct a <code>LinmapQuant</code> is to construct a <code>UnitMap</code> and multiply it to a matrix or use the constructor. <code>UnitMap</code> is generic and allows for units or dimensions.</p><pre><code class="language-julia hljs">X = randn(20, 5)*rand(5,5)

#Make sure to invert u_in if you want to assign units directly
julia&gt; X * UnitMap(u_in=inv.([u&quot;K&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=fill(u&quot;&quot;, size(X,1))) 
20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:
  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A
 -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A

#Scalar arguments are repeated along the dimension for convenience
julia&gt; X * UnitMap(u_in=inv.([u&quot;K&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=u&quot;&quot;) 
20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:
  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A
 -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A

#Affine units can be used inside a UnitMap
julia&gt; UnitMap(u_in=[u&quot;°C&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;], u_out=u&quot;&quot;) 
UnitMap{Units{Dimensions{FixRat32}, AffineTransform{Float64}}, Vector{Units{Dimensions{FixRat32}, AffineTransform{Float64}}}, Units{Dimensions{FixRat32}, AffineTransform{Float64}}}(Units{Dimensions{FixRat32}, AffineTransform{Float64}}[°C, km, mol, kg, A], )

#Affine units cannot be used for a DimsMap however
julia&gt; X * UnitMap(u_in=inv.([u&quot;°C&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=u&quot;&quot;) 
ERROR: NotScalarError: °C cannot be treated as scalar, operation only valid for scalar units</code></pre><p>Using <code>UnitMap</code> will create a modified matrix (ensuring all values are dimensional). For more efficiency, one can use <code>DimsMap</code>, which won&#39;t allocate a new array, but this object has stricter requirements. <code>DimsMap</code> only accepts vector arguments (which must be appropriately sized), and only dimensional units (i.e. SI) can be used (so that the matrix of numbers is not modified).</p><pre><code class="language-julia hljs">#DimsMap is more efficient (doens&#39;t reallocate X) but is fussier
julia&gt; X * DimsMap(u_in=inv.([u&quot;K&quot;, u&quot;m&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=fill(u&quot;&quot;, size(X,1))) 
20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:
  0.423785 K     1.44668 m   1.43043 mol   0.271962 kg    2.35996 A
 -0.601045 K    0.150874 m  0.608505 mol  -0.146254 kg   0.509313 A

#Vector inputs are required
julia&gt; X * DimsMap(u_in=inv.([u&quot;K&quot;, u&quot;m&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=u&quot;&quot;) 
ERROR: MethodError: no method matching DimsMap(::Nothing, ::Vector{Units{Dimensions{…}, AffineTransform{…}}}, ::StaticUnits{, AffineTransform{Float64}})

#Units must be dimensional (i.e. SI)
julia&gt; X * DimsMap(u_in=inv.([u&quot;K&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=fill(u&quot;&quot;, size(X,1))) 
ERROR: ArgumentError: &#39;u_in&#39; argument must directly map to dimensions Dimensions{FixRat32}[1/K, 1/m, 1/mol, 1/kg, 1/A] without scaling</code></pre><p>Multiplication is simply shorthand for the <code>LinmapQuant</code> constructor that can also be used</p><pre><code class="language-julia hljs">#You can also use LinmapQuant constructor
julia&gt; LinmapQuant(X, UnitMap(u_in=inv.([u&quot;K&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u_out=u&quot;&quot;)) 
20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:
  0.423785 K   1446.68 m   1.43043 mol   0.271962 kg    2.35996 A
 -0.601045 K   150.874 m  0.608505 mol  -0.146254 kg   0.509313 A</code></pre><h3 id="Matrix-Factorizations"><a class="docs-heading-anchor" href="#Matrix-Factorizations">Matrix Factorizations</a><a id="Matrix-Factorizations-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Factorizations" title="Permalink"></a></h3><p>Some matrix factorizations are also enabled by FlexUnits. Currently, the supported factorization functions include <code>lu</code>, <code>cholesky</code>, and <code>eigen</code>. Certain factorization have constraints on the pattern of units supported. </p><ul><li><code>lu</code> has no constraints</li><li><code>cholesky</code> only supports symmetric unit mappings</li><li><code>eigen</code> only supports symmetric and repeatable unit mappings (where repeatable means the output units are proportional to input units)</li></ul><p>Let us consider an example with a covariance matrix, which is compatible with all of the factorizations mentioned above.</p><pre><code class="language-julia hljs">using Statistics
X = randn(30,3)*rand(3,3) * UnitMap(u_out=u&quot;&quot;, u_in=inv.(SA[u&quot;ft&quot;, u&quot;W&quot;, u&quot;psi&quot;]))

julia&gt; S = cov(collect(X)) #Specialized LinmapQuant version doesn&#39;t exist yet
3×3 Matrix{Quantity{Float64, Dimensions{FixRat32}}}:
        0.0301835 m²  0.178333 (m³ kg)/s³          451.029 kg/s²
 0.178333 (m³ kg)/s³  1.18397 (m⁴ kg²)/s⁶     3101.84 (m kg²)/s⁵
       451.029 kg/s²   3101.84 (m kg²)/s⁵  1.15374e7 kg²/(m² s⁴)</code></pre><h4 id="LU-Factorization"><a class="docs-heading-anchor" href="#LU-Factorization">LU Factorization</a><a id="LU-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#LU-Factorization" title="Permalink"></a></h4><p>LU Factoriztion works on LinmapQuant and a selection of matrix types containing quantities. If your desired matrix type isn&#39;t supported, you may want to try using <code>FlexUnits.qlu</code>. You can access factorizations with <code>.L</code> and <code>.U</code> and the permutation vector with <code>.p</code></p><pre><code class="language-julia hljs">slu = lu(S)

julia&gt; slu.L
3×3 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
        1.0 kg/(m² s²)  0.0 kg/(m² s²)  0.0 kg/(m² s²)
 0.000395392 (m kg)/s³   1.0 (m kg)/s³   0.0 (m kg)/s³
           6.69216e-5        0.688662             1.0

julia&gt; slu.U
3×3 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
 451.029 m²    3101.84 (m³ kg)/s³  1.15374e7 kg/s²
     0.0 m²  -0.042469 (m³ kg)/s³   -1459.96 kg/s²
     0.0 m²        0.0 (m³ kg)/s³    684.349 kg/s²
</code></pre><h4 id="Cholesky-Factorization"><a class="docs-heading-anchor" href="#Cholesky-Factorization">Cholesky Factorization</a><a id="Cholesky-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Cholesky-Factorization" title="Permalink"></a></h4><p>Much like LU factorization, you can also perform Cholesky factorization on a matrix of quantities. If your desired matrix type isn&#39;t supported you can use <code>FlexUnits.qcholesky</code>.</p><pre><code class="language-julia hljs">schol = cholesky(S)

julia&gt; schol.U
3×3 LinmapQuant{Float64, Dimensions{FixRat32}, UpperTriangular{Float64, Matrix{Float64}}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
 0.173734 m   1.02647 (m² kg)/s³  2596.09 kg/(m s²)
      0.0 m  0.361012 (m² kg)/s³  1210.57 kg/(m s²)
      0.0 m       0.0 (m² kg)/s³  1825.45 kg/(m s²)

julia&gt; schol.L
3×3 LinmapQuant{Float64, Dimensions{FixRat32}, LowerTriangular{Float64, Matrix{Float64}}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
         0.173734 m                0.0 m              0.0 m
 1.02647 (m² kg)/s³  0.361012 (m² kg)/s³     0.0 (m² kg)/s³
  2596.09 kg/(m s²)    1210.57 kg/(m s²)  1825.45 kg/(m s²)</code></pre><h4 id="Eigenvalue-Decomposition"><a class="docs-heading-anchor" href="#Eigenvalue-Decomposition">Eigenvalue Decomposition</a><a id="Eigenvalue-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Eigenvalue-Decomposition" title="Permalink"></a></h4><p>Eigenvalue decomposition can also be performed by calling <code>eigen</code>. If this matrix type isn&#39;t supproted, you can also attempt to use <code>FlexUnits.qeigen</code>. You can access the fields <code>.vectors</code> and <code>.values</code> as normal.</p><pre><code class="language-julia hljs">seig = eigen(S)

julia&gt; seig.vectors
3×3 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:
           0.986733 m            -0.162351 m            3.90927e-5 m
 -0.162351 (m² kg)/s³   -0.986733 (m² kg)/s³  0.000268851 (m² kg)/s³
 5.07415e-6 kg/(m s²)  0.000271631 kg/(m s²)           1.0 kg/(m s²)

julia&gt; seig.values
3-element Vector{Float64}:
 0.0031610089377130763
 0.35943390882999254
 1.1537410911880754e7
 ```

### Optimizations and pitfalls
The goal is to optimize all possible linear algebra opterations on matrices that can be found in LinearAlgebra. However, some operations might resort to unoptimized fallbacks, particularly if a an optimized function or matrix type hasn&#39;t been implemented yet. The general rule is that if the operation returns a &quot;LinmapQuant&quot; or &quot;VectorQuant&quot;, it has been optimized. As of the current release, matrix operators should optimized.
</code></pre><p>julia X = (randn(20, 5)*randn(5,5)) * UnitMap(u<em>in=inv.([u&quot;K&quot;, u&quot;km&quot;, u&quot;mol&quot;, u&quot;kg&quot;, u&quot;A&quot;]), u</em>out = u&quot;&quot;)</p><p>#Adjoints of LinmapQuant should work julia&gt; X&#39;*X  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:       91.9205 K²    41503.5 (m K)    -36.038 (K mol)     109.162 (kg K)   -40.1446 (A K)    41503.5 (m K)      2.7836e7 m²    3810.33 (m mol)     57686.8 (m kg)   -19885.5 (m A)</p><p>#Multiplications with unoptimized matrices should return an optimized version julia&gt; collect(X&#39;)*X  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:       91.9205 K²    41503.5 (m K)    -36.038 (K mol)     109.162 (kg K)   -40.1446 (A K)    41503.5 (m K)      2.7836e7 m²    3810.33 (m mol)     57686.8 (m kg)   -19885.5 (m A)</p><p>#Inversions should work julia&gt; inv(collect(X&#39;)*X)  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:         0.595211 1/K²     0.000584858 1/(m K)    0.00165344 1/(K mol)     -0.66111 1/(kg K)       0.14344 1/(A K)   0.000584858 1/(m K)         2.23064e-6 1/m²  -0.000378828 1/(m mol)  -0.00129237 1/(m kg)   0.000471164 1/(m A)</p><p>#Matrix divisions should work julia&gt; (X&#39;<em>X)(X&#39;</em>X)  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:                1.0     -1.79517e-13 m/K    3.46556e-15 mol/K    8.31693e-16 kg/K     3.71834e-15 A/K     1.83657e-17 K/m                1.0     4.06306e-18 mol/m   -2.30576e-19 kg/m     4.72759e-18 A/m</p><p>#Matrix divisions should work if denominator is optimized julia&gt; collect((X&#39;<em>X))/(X&#39;</em>X)  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:               1.0     1.83657e-17 K/m  -2.07142e-15 K/mol    -1.40926e-14 K/kg    4.03822e-15 K/A   -1.79517e-13 m/K               1.0   -2.13253e-14 m/mol      1.1747e-13 m/kg           -0.0 m/A</p><p>#Addition/Subtraction with unoptimized matrices should work julia&gt; collect(X) + X  20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:     7.2873 K   823.543 m   -7.70232 mol    6.54604 kg  -2.10165 A    5.14641 K   2081.26 m   -7.58251 mol    5.00889 kg  -6.87539 A</p><p>#Matrix powers will work if output units are similar to input units (can differ by a factor) julia&gt; ((X&#39;<em>X)(X&#39;</em>X)*u&quot;s&quot;)^2  5×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}}:                   1.0 s²    -3.59033e-13 (m s²)/K    6.93113e-15 (s² mol)/K    1.66339e-15 (kg s²)/K     7.43669e-15 (s² A)/K     3.67315e-17 (s² K)/m                   1.0 s²    8.12611e-18 (s² mol)/m   -4.61153e-19 (kg s²)/m     9.45517e-18 (s² A)/m</p><pre><code class="nohighlight hljs">
Broadcasting should work, but unfortunately, will not be optimized unless both values are a LinmapQuant. This is becuase broadcasting operations do not require both matrices to be proper linear mappings, and multiplication with a generic matrix can destroy this property.</code></pre><p>julia #Broadcasted operations will maintain factorization if all arguments are factorized julia&gt; X .* X  20×5 LinmapQuant{Float64, Dimensions{FixRat32}, Matrix{Float64}, DimsMap{Dimensions{FixRat32}, Vector{Dimensions{FixRat32}}, Vector{Dimensions{FixRat32}}}:    13.2762 K²  1.69556e5 m²     14.8314 mol²    10.7127 kg²   1.10423 A²    6.62139 K²  1.08291e6 m²     14.3736 mol²    6.27226 kg²   11.8177 A²</p><p>#Factorization is lost with broadcasting if any argument is not factorized (observe the Matrix return type) julia&gt; X .* collect(X)  20×5 Matrix{Quantity{Float64, Dimensions{FixRat32}}}:    13.2762 K²  1.69556e5 m²     14.8314 mol²    10.7127 kg²   1.10423 A²    6.62139 K²  1.08291e6 m²     14.3736 mol²    6.27226 kg²   11.8177 A² ```</p><h2 id="Factored-Unit-Shortcuts"><a class="docs-heading-anchor" href="#Factored-Unit-Shortcuts">Factored Unit Shortcuts</a><a id="Factored-Unit-Shortcuts-1"></a><a class="docs-heading-anchor-permalink" href="#Factored-Unit-Shortcuts" title="Permalink"></a></h2><p>Shortcut tricks for factored units exist for many different matrix types and operations. More will likely be discovered and added in the future.</p><h3 id="DimsMap-Matrix-Multiplication"><a class="docs-heading-anchor" href="#DimsMap-Matrix-Multiplication">DimsMap Matrix Multiplication</a><a id="DimsMap-Matrix-Multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#DimsMap-Matrix-Multiplication" title="Permalink"></a></h3><p>To solve the <code>DimsMap</code> problem for matrix multiplication <code>m*n</code>, one simply has to perform these steps:</p><ol><li>Ensure that <code>u_in</code> for <code>m</code> is the inverse of the <code>u_out</code> for <code>n</code> (an O(N) operation)</li><li>Multiply the <code>u_fac</code> values of both matrices (an O(1) operation)</li><li>Construct a new <code>DimsMap</code> object with the <code>u_out</code> for <code>m</code>, the <code>u_in</code> for <code>n</code> and the <code>u_fac</code> from step 2</li></ol><p>The entire <code>DimsMap</code> solution is O(N) where N is the number of columns in <code>m</code>.</p><h3 id="DimsMap-Matrix-Inversion"><a class="docs-heading-anchor" href="#DimsMap-Matrix-Inversion">DimsMap Matrix Inversion</a><a id="DimsMap-Matrix-Inversion-1"></a><a class="docs-heading-anchor-permalink" href="#DimsMap-Matrix-Inversion" title="Permalink"></a></h3><p>To solve the <code>DimsMap</code> problem for a matrix inversion of <code>m</code>, one simplyh has to perform these steps:</p><ol><li>Invert the <code>u_fac</code> for <code>m</code> (an O(1) operation)</li><li>Construct a new <code>DimsMap</code> object from the <code>u_fac</code> result in step 1 and swapping the <code>u_in</code> and <code>u_out</code> vectors (an O(1) operation)</li></ol><p>The entire <code>DimsMap</code> solution in this case is O(1)</p><h3 id="DimsMap-Matrix-Powers"><a class="docs-heading-anchor" href="#DimsMap-Matrix-Powers">DimsMap Matrix Powers</a><a id="DimsMap-Matrix-Powers-1"></a><a class="docs-heading-anchor-permalink" href="#DimsMap-Matrix-Powers" title="Permalink"></a></h3><p>Only certain unit structures can be raised to a power, because in order for an <code>m*n</code> multiplication to work the input units of <code>m</code> must be dimensionally proprotional to the output units of <code>n</code>. Since <code>DimsMap</code> factors out these proportions, one can simply check for equality between <code>u_in</code> and <code>u_out</code> of the two matrices. Thus for a matrix power, one simply has to:</p><ol><li>Verify that <code>u_in</code> is equal to <code>u_out</code></li><li>Raise the <code>u_fac</code> value by the desired power</li></ol><h3 id="More-operations-coming"><a class="docs-heading-anchor" href="#More-operations-coming">More operations coming</a><a id="More-operations-coming-1"></a><a class="docs-heading-anchor-permalink" href="#More-operations-coming" title="Permalink"></a></h3><p>Potential shortcut methods for <code>DimsMap</code> objects abound and can likely be applied to factorizations like eigendecomposition and cholesky factorization. Broadcasting operations are also likely targets to be short-cutted. To test if a shortcut method currently exists, simply perform it on <code>LinmapQuant</code> objects or <code>VectorQuant</code> objects. If a <code>LinmapQuant</code> or a <code>VectorQuant</code> object is returned, a shortcut method has been implemented. Otherwise a generic fallback has been used. This package also has semi-shortcut methods for combined operations between factorized <code>LinmapQuant</code>/<code>VectorQuant</code> objects and generic vectors and matrices of quantities. These methods tend to be O(N²), which is still better than the likely O(N³) alternative, but the advantage is that the resturn value should be factorized, optimizing long chains of linear algebra operations where possible.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manipulation/">« Unit Manipulation</a><a class="docs-footer-nextpage" href="../examples/">Advanced Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 14 February 2026 00:09">Saturday 14 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
